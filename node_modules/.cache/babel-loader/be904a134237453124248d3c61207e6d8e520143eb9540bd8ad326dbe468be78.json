{"ast":null,"code":"import _objectWithoutProperties from \"/home/sofiane/Desktop/Crop Nutrition Optimizer/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/home/sofiane/Desktop/Crop Nutrition Optimizer/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"excludeRects\"];\nimport { isNil, last, repeat, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport bidiFactory from 'bidi-js';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us.js';\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Fragment} Fragment\n */\n\n/**\n * Create attributed string from text fragments\n *\n * @param {Fragment[]} fragments fragments\n * @returns {AttributedString} attributed string\n */\nconst fromFragments = fragments => {\n  let offset = 0;\n  let string = '';\n  const runs = [];\n  fragments.forEach(fragment => {\n    string += fragment.string;\n    runs.push(_objectSpread(_objectSpread({}, fragment), {}, {\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    }));\n    offset += fragment.string.length;\n  });\n  return {\n    string,\n    runs\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param {string} word\n * @returns {[string]} same word\n */\nconst defaultHyphenationEngine = word => [word];\n\n/**\n * Wrap words of attribute string\n *\n * @param {Object} engines layout engines\n * @param {Object} options layout options\n */\nconst wrapWords = function (engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string including syllables\n   */\n  return attributedString => {\n    var _engines$wordHyphenat, _engines;\n    const syllables = [];\n    const fragments = [];\n    const hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;\n    for (let i = 0; i < attributedString.runs.length; i += 1) {\n      let string = '';\n      const run = attributedString.runs[i];\n      const words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n      for (let j = 0; j < words.length; j += 1) {\n        const word = words[j];\n        const parts = hyphenateWord(word);\n        syllables.push(...parts);\n        string += parts.join('');\n      }\n      fragments.push(_objectSpread(_objectSpread({}, run), {}, {\n        string\n      }));\n    }\n    return _objectSpread(_objectSpread({}, fromFragments(fragments)), {}, {\n      syllables\n    });\n  };\n};\n\n/**\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Clone rect\n *\n * @param {Rect} rect rect\n * @returns {Rect} cloned rect\n */\nconst copy = rect => {\n  return Object.assign({}, rect);\n};\n\n/**\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n *\n * @param {Rect} rect rect\n * @param {number} height height\n * @returns {[Rect, Rect]} partitioned rects\n */\nconst partition = (rect, height) => {\n  const a = Object.assign({}, rect, {\n    height\n  });\n  const b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n\n/**\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Crop upper section of rect\n *\n * @param {number} height height\n * @param {Rect} rect rect\n * @returns {Rect} cropped rect\n */\nconst crop = (height, rect) => {\n  const [, result] = partition(rect, height);\n  return result;\n};\n\n/**\n * Get paragraph block height\n *\n * @param {Object}  paragraph block\n * @returns {number} paragraph block height\n */\nconst height$2 = paragraph => {\n  return paragraph.reduce((acc, block) => acc + block.box.height, 0);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Calculate run scale\n *\n * @param {Run} run run\n * @returns {number} scale\n */\nconst calculateScale = run => {\n  var _attributes$font;\n  const attributes = run.attributes || {};\n  const fontSize = attributes.fontSize || 12;\n  const unitsPerEm = (_attributes$font = attributes.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n\n/**\n * Get run scale\n *\n * @param {Object}  run\n * @returns {number} scale\n */\nconst scale = run => {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param {number} index\n * @param {Run} run run\n * @returns {number} ligature offset\n */\nconst offset = (index, run) => {\n  if (!run) return 0;\n  const glyphIndices = run.glyphIndices || [];\n  const value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(i => i === value).length;\n};\n\n/**\n * @typedef {import('../types.js').Font} Font\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run font\n *\n * @param {Run} run run\n * @returns {Font | null} font\n */\nconst getFont = run => {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;\n};\n\n/**\n * @typedef {import('../types.js').Font} Font\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param {number} start start code point index\n * @param {number} end end code point index\n * @param {Font} font font to generate new glyph\n * @param {Glyph} glyph glyph to be sliced\n * @returns {Glyph[]} sliced glyph parts\n */\nconst slice$2 = (start, end, font, glyph) => {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  const codePoints = glyph.codePoints.slice(start, end);\n  const string = String.fromCodePoint(...codePoints);\n\n  // passing LTR To force fontkit to not reverse the string\n  return font ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs : [glyph];\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param {number} index index\n * @param {Run} run run\n * @returns {number} glyph index\n */\nconst glyphIndexAt = (index, run) => {\n  var _run$glyphIndices;\n  const result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param {number[]} array list\n * @returns {number[]} normalized array\n */\nconst normalize = array => {\n  const head = array[0];\n  return array.map(value => value - head);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Slice run between glyph indices range\n *\n * @param {number} start glyph index\n * @param {number} end glyph index\n * @param {Run} run run\n * @returns {Run} sliced run\n */\nconst slice$1 = (start, end, run) => {\n  var _run$glyphs, _run$glyphs2;\n  const runScale = scale(run);\n  const font = getFont(run);\n\n  // Get glyph start and end indices\n  const startIndex = glyphIndexAt(start, run);\n  const endIndex = glyphIndexAt(end, run);\n\n  // Get start and end glyph\n  const startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  const endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex];\n\n  // Get start ligature chunks (if any)\n  const startOffset = offset(start, run);\n  const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\n\n  // Get end ligature chunks (if any)\n  const endOffset = offset(end, run);\n  const endGlyphs = slice$2(0, endOffset, font, endGlyph);\n\n  // Compute new glyphs\n  const sliceStart = startIndex + Math.min(1, startOffset);\n  const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\n\n  // Compute new positions\n  const glyphPosition = g => ({\n    xAdvance: g.advanceWidth * runScale\n  });\n  const startPositions = startGlyphs.map(glyphPosition);\n  const positions = (run.positions || []).slice(sliceStart, endIndex);\n  const endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run index that contains passed index\n *\n * @param {number} n index\n * @param {Run[]} runs runs\n * @returns {number} run index\n */\nconst runIndexAt$1 = (n, runs) => {\n  if (!runs) return -1;\n  return runs.findIndex(run => run.start <= n && n < run.end);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Filter runs contained between start and end\n *\n * @param {number} start\n * @param {number} end\n * @param {Run[]} runs\n * @returns {Run[]} filtered runs\n */\nconst filter = (start, end, runs) => {\n  const startIndex = runIndexAt$1(start, runs);\n  const endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Subtract scalar to run\n *\n * @param {number} n scalar\n * @param {Run} run run\n * @returns {Object} subtracted run\n */\nconst subtract = (n, run) => {\n  const start = run.start - n;\n  const end = run.end - n;\n  return Object.assign({}, run, {\n    start,\n    end\n  });\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Slice array of runs\n *\n * @param {number} start offset\n * @param {number} end offset\n * @param {Run[]} runs\n * @returns {Run[]} sliced runs\n */\nconst sliceRuns = (start, end, runs) => {\n  const sliceFirstRun = a => slice$1(start - a.start, end - a.start, a);\n  const sliceLastRun = a => slice$1(0, end - a.start, a);\n  return runs.map((run, i) => {\n    let result = run;\n    const isFirst = i === 0;\n    const isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n\n/**\n * Slice attributed string between two indices\n *\n * @param {number} start offset\n * @param {number} end offset\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string\n */\nconst slice = (start, end, attributedString) => {\n  if (attributedString.string.length === 0) return attributedString;\n  const string = attributedString.string.slice(start, end);\n  const filteredRuns = filter(start, end, attributedString.runs);\n  const slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string,\n    runs: slicedRuns\n  });\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * @param {string} string\n * @returns {number} index\n */\nconst findCharIndex = string => {\n  return string.search(/\\S/g);\n};\n\n/**\n * @param {string} string\n * @returns {number} index\n */\nconst findLastCharIndex = string => {\n  const match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string\n */\nconst trim = attributedString => {\n  const start = findCharIndex(attributedString.string);\n  const end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Returns empty run\n *\n * @returns {Run} empty run\n */\nconst empty$1 = () => {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n\n/**\n * Check if value is a number\n *\n * @template {unknown} T\n * @param {T} value Value to check\n * @returns {value is number} Whether value is a number\n */\nconst isNumber = value => {\n  return typeof value === 'number';\n};\n\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param {number} length length\n * @param {number[]} indices glyph indices\n * @returns {number[]} extended glyph indices\n */\nconst appendIndices = (length, indices) => {\n  const lastIndex = last(indices);\n  const value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  const newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n\n/**\n * @typedef {import('../types.js').Font} Font\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\n/**\n * Get glyph for a given code point\n *\n * @param {number} [value] codePoint\n * @param {Font} [font] font\n * @returns {Glyph} glyph\n * */\nconst fromCodePoint = (value, font) => {\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\n * @typedef {import('../types.js').Glyph} Glyph\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Append glyph to run\n *\n * @param {Glyph} glyph glyph\n * @param {Run} run run\n * @returns {Run} run with glyph\n */\nconst appendGlyph = (glyph, run) => {\n  var _glyph$codePoints;\n  const glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  const end = run.end + glyphLength;\n  const glyphs = run.glyphs.concat(glyph);\n  const glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end,\n    glyphs,\n    glyphIndices\n  });\n  const positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run)\n  });\n  return Object.assign({}, run, {\n    end,\n    glyphs,\n    glyphIndices,\n    positions\n  });\n};\n\n/**\n * Append glyph or code point to run\n *\n * @param {Glyph | number | undefined} value glyph or codePoint\n * @param {Run} run run\n * @returns {Run} run with glyph\n */\nconst append$1 = (value, run) => {\n  if (!value) return run;\n  const font = getFont(run);\n  const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n\n/**\n * Get string from array of code points\n *\n * @param {number[]} codePoints points\n * @returns {string} string\n */\nconst stringFromCodePoints = codePoints => {\n  return String.fromCodePoint(...(codePoints || []));\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\n/**\n * Append glyph into last run of attributed string\n *\n * @param {Glyph} glyph glyph\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string with new glyph\n */\nconst append = (glyph, attributedString) => {\n  const codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  const codePointsString = stringFromCodePoints(codePoints);\n  const string = attributedString.string + codePointsString;\n  const firstRuns = attributedString.runs.slice(0, -1);\n  const lastRun = last(attributedString.runs) || empty$1();\n  const runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\nconst ELLIPSIS_UNICODE = 8230;\nconst ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param {Object} font\n * @returns {Object} ellipsis codepoint\n */\nconst getEllipsisCodePoint = font => {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n  const [codePoints] = font.encode(ELLIPSIS_STRING);\n  return parseInt(codePoints[0], 16);\n};\n\n/**\n * Trucante block with ellipsis\n *\n * @param {Object} block paragraph block\n * @returns {Object} sliced paragraph block\n */\nconst truncate = block => {\n  var _last, _last2, _last2$attributes;\n  const runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  const font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;\n  if (font) {\n    const index = block.length - 1;\n    const codePoint = getEllipsisCodePoint(font);\n    const glyph = font.glyphForCodePoint(codePoint);\n    const lastBlock = append(glyph, trim(block[index]));\n    return Object.assign([], block, {\n      [index]: lastBlock\n    });\n  }\n  return block;\n};\n\n/**\n * @typedef {import('../types.js').Attributes} Attributes\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Omit attribute from run\n *\n * @param {keyof Attributes} value attribute value\n * @param {Run} run run\n * @returns {Run} run without ommited attribute\n */\nconst omit = (value, run) => {\n  const attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes\n  });\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run ascent\n *\n * @param {Run} run run\n * @returns {number} ascent\n */\nconst ascent$1 = run => {\n  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;\n  const attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;\n  const fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run descent\n *\n * @param {Run} run run\n * @returns {number} descent\n */\nconst descent = run => {\n  var _run$attributes, _run$attributes$font;\n  const fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;\n  return scale(run) * fontDescent;\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run lineGap\n *\n * @param {Object} run run\n * @returns {number} lineGap\n */\nconst lineGap = run => {\n  var _run$attributes, _run$attributes$font;\n  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale(run);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run height\n *\n * @param {Run} run run\n * @returns {number} height\n */\nconst height$1 = run => {\n  var _run$attributes;\n  const lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Returns attributed string height\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} height\n */\nconst height = attributedString => {\n  const reducer = (acc, run) => Math.max(acc, height$1(run));\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Checks if two rects intersect each other\n *\n * @param {Rect} a rect A\n * @param {Rect} b rect B\n * @returns {boolean} whether rects intersect\n */\nconst intersects = (a, b) => {\n  const x = Math.max(a.x, b.x);\n  const num1 = Math.min(a.x + a.width, b.x + b.width);\n  const y = Math.max(a.y, b.y);\n  const num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\nconst getLineFragment = (lineRect, excludeRect) => {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  const eStart = excludeRect.x;\n  const eEnd = excludeRect.x + excludeRect.width;\n  const lStart = lineRect.x;\n  const lEnd = lineRect.x + lineRect.width;\n  const a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  const b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(r => r.width > 0);\n};\nconst getLineFragments = (rect, excludeRects) => {\n  let fragments = [rect];\n  for (let i = 0; i < excludeRects.length; i += 1) {\n    const excludeRect = excludeRects[i];\n    fragments = fragments.reduce((acc, fragment) => {\n      const pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  }\n  return fragments;\n};\nconst generateLineRects = (container, height) => {\n  const {\n      excludeRects\n    } = container,\n    rect = _objectWithoutProperties(container, _excluded);\n  if (!excludeRects) return [rect];\n  const lineRects = [];\n  const maxY = Math.max(...excludeRects.map(r => r.y + r.height));\n  let currentRect = rect;\n  while (currentRect.y < maxY) {\n    const [lineRect, rest] = partition(currentRect, height);\n    const lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push(...lineRectFragments);\n  }\n  return [...lineRects, currentRect];\n};\nconst ATTACHMENT_CODE$1 = '\\ufffc'; // 65532\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Remove attachment attribute if no char present\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string\n */\nconst purgeAttachments = attributedString => {\n  const shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return attributedString;\n  const runs = attributedString.runs.map(run => omit('attachment', run));\n  return Object.assign({}, attributedString, {\n    runs\n  });\n};\n\n/**\n * Layout paragraphs inside rectangle\n *\n * @param {Object} rects rect\n * @param {Object[]} lines attributed strings\n * @param {number} indent\n * @returns {Object} layout blocks\n */\nconst layoutLines = (rects, lines, indent) => {\n  let rect = rects.shift();\n  let currentY = rect.y;\n  return lines.map((line, i) => {\n    var _line$runs, _line$runs$;\n    const lineIndent = i === 0 ? indent : 0;\n    const style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    const height$1 = Math.max(height(line), style.lineHeight);\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n    const newLine = Object.assign({}, line);\n    delete newLine.syllables;\n    newLine.box = {\n      x: rect.x + lineIndent,\n      y: currentY,\n      width: rect.width - lineIndent,\n      height: height$1\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n\n/**\n * Performs line breaking and layout\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n */\nconst layoutParagraph = (engines, options) => {\n  /**\n   * @param {Rect} container rect\n   * @param {Object} paragraph attributed string\n   * @returns {Object} layout block\n   */\n  return (container, paragraph) => {\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\n    const height$1 = height(paragraph);\n    const indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\n    const rects = generateLineRects(container, height$1);\n    const availableWidths = rects.map(r => r.width);\n    availableWidths.unshift(availableWidths[0] - indent);\n    const lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n\n/**\n * Slice block at given height\n *\n * @param {number} height height\n * @param {Object} block paragraph block\n * @returns {number[]} sliced paragraph block\n */\nconst sliceAtHeight = (height, block) => {\n  const newBlock = [];\n  let counter = 0;\n  for (let i = 0; i < block.length; i += 1) {\n    const line = block[i];\n    counter += line.box.height;\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n  return newBlock;\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n * @param {Rect} container container rect\n */\nconst typesetter = (engines, options, container) => {\n  /**\n   * @param {AttributedString} attributedStrings attributed strings (paragraphs)\n   * @returns {Object[]} paragraph blocks\n   */\n  return attributedStrings => {\n    const blocks = [];\n    const paragraphs = [...attributedStrings];\n    const layoutBlock = layoutParagraph(engines, options);\n    const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    const truncateEllipsis = container.truncateMode === 'ellipsis';\n    let linesCount = maxLines;\n    let paragraphRect = copy(container);\n    let nextParagraph = paragraphs.shift();\n    while (linesCount > 0 && nextParagraph) {\n      const block = layoutBlock(paragraphRect, nextParagraph);\n      const slicedBlock = block.slice(0, linesCount);\n      const linesHeight = height$2(slicedBlock);\n      const shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n      if (paragraphRect.height >= linesHeight) {\n        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n    return blocks;\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string start value\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} start\n */\nconst start = attributedString => {\n  const {\n    runs\n  } = attributedString;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string end value\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} end\n */\nconst end = attributedString => {\n  const {\n    runs\n  } = attributedString;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string length\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} end\n */\nconst length$1 = attributedString => {\n  return end(attributedString) - start(attributedString);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Glyph} Glyph\n * @typedef {import('../types.js').Position} Position\n * @typedef {import('../types.js').Run} Run\n */\n\nconst bidi$2 = bidiFactory();\n\n/**\n * @param {Run[]} runs\n * @returns {number[]} bidi levels\n */\nconst getBidiLevels$1 = runs => {\n  return runs.reduce((acc, run) => {\n    const length = run.end - run.start;\n    const levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\nconst getReorderedIndices = (string, segments) => {\n  // Fill an array with indices\n  const indices = [];\n  for (let i = 0; i < string.length; i += 1) {\n    indices[i] = i;\n  }\n  // Reverse each segment in order\n  segments.forEach(_ref => {\n    let [start, end] = _ref;\n    const slice = indices.slice(start, end + 1);\n    for (let i = slice.length - 1; i >= 0; i -= 1) {\n      indices[end - i] = slice[i];\n    }\n  });\n  return indices;\n};\n\n/**\n * @template {'glyphs'|'positions'} T\n * @param {Run[]} runs\n * @param {T} objectName\n * @param {number} index\n * @returns {T extends 'glyphs' ? Glyph|undefined : Position|undefined}\n */\nconst getItemAtIndex = (runs, objectName, index) => {\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n    const updatedIndex = run.glyphIndices[index - run.start];\n    if (index >= run.start && index < run.end) {\n      return run[objectName][updatedIndex];\n    }\n  }\n  throw new Error(\"index \".concat(index, \" out of range\"));\n};\n\n/**\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} reordered attributed string\n */\nconst reorderLine = attributedString => {\n  var _attributedString$run;\n  const levels = getBidiLevels$1(attributedString.runs);\n  const direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\n  const level = direction === 'rtl' ? 1 : 0;\n  const end = length$1(attributedString) - 1;\n  const paragraphs = [{\n    start: 0,\n    end,\n    level\n  }];\n  const embeddingLevels = {\n    paragraphs,\n    levels\n  };\n  const segments = bidi$2.getReorderSegments(attributedString.string, embeddingLevels);\n\n  // No need for bidi reordering\n  if (segments.length === 0) return attributedString;\n  const indices = getReorderedIndices(attributedString.string, segments);\n  const updatedString = bidi$2.getReorderedString(attributedString.string, embeddingLevels);\n  const updatedRuns = attributedString.runs.map(run => {\n    const selectedIndices = indices.slice(run.start, run.end);\n    const updatedGlyphs = [];\n    const updatedPositions = [];\n    const addedGlyphs = new Set();\n    for (let i = 0; i < selectedIndices.length; i += 1) {\n      const index = selectedIndices[i];\n      const glyph = getItemAtIndex(attributedString.runs, 'glyphs', index);\n      if (addedGlyphs.has(glyph.id)) continue;\n      updatedGlyphs.push(glyph);\n      updatedPositions.push(getItemAtIndex(attributedString.runs, 'positions', index));\n      if (glyph.isLigature) {\n        addedGlyphs.add(glyph.id);\n      }\n    }\n    return _objectSpread(_objectSpread({}, run), {}, {\n      glyphs: updatedGlyphs,\n      positions: updatedPositions\n    });\n  });\n  return _objectSpread(_objectSpread({}, attributedString), {}, {\n    runs: updatedRuns,\n    string: updatedString\n  });\n};\n\n/**\n * Reorder a paragraph\n *\n * @param {AttributedString[]} lines\n * @returns {AttributedString[]} reordered lines\n */\nconst reorderParagraph = lines => lines.map(reorderLine);\n\n/**\n * Perform bidi reordering\n *\n * @returns {(paragraphs: AttributedString[][]) => AttributedString[][]} reordered paragraphs\n */\nconst bidiReordering = () => {\n  /**\n   * @param {AttributedString[][]} paragraphs line blocks\n   * @returns {AttributedString[][]} reordered line blocks\n   */\n  return paragraphs => paragraphs.map(reorderParagraph);\n};\n\n/**\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\nconst DUMMY_CODEPOINT = 123;\n\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param {Glyph[]} glyphs\n * @returns {number[]} glyph indices\n */\nconst resolve = function (glyphs) {\n  if (glyphs === void 0) {\n    glyphs = [];\n  }\n  return glyphs.reduce((acc, glyph) => {\n    const codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(() => 0);\n    const last = acc[acc.length - 1];\n    const next = codePoints.map(() => last + 1);\n    return [...acc, ...next];\n  }, []);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Position} Position\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * @param {Run} run\n * @returns {number}\n */\nconst getCharacterSpacing = run => {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;\n};\n\n/**\n * Scale run positions\n *\n * @param {Run} run\n * @param {Position[]} positions\n * @returns {Position[]} scaled positions\n */\nconst scalePositions = (run, positions) => {\n  const runScale = scale(run);\n  const characterSpacing = getCharacterSpacing(run);\n  return positions.map((position, i) => {\n    const isLast = i === positions.length;\n    const xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n\n/**\n * Create glyph run\n *\n * @param {string} string string\n */\nconst layoutRun = string => {\n  /**\n   * @param {Run} run run\n   * @returns {Run} glyph run\n   */\n  return run => {\n    const {\n      start,\n      end,\n      attributes = {}\n    } = run;\n    const {\n      font\n    } = attributes;\n    if (!font) return _objectSpread(_objectSpread({}, run), {}, {\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    });\n    const runString = string.slice(start, end);\n\n    // passing LTR To force fontkit to not reverse the string\n    const glyphRun = font.layout(runString, undefined, undefined, undefined, 'ltr');\n    const positions = scalePositions(run, glyphRun.positions);\n    const glyphIndices = resolve(glyphRun.glyphs);\n    return _objectSpread(_objectSpread({}, run), {}, {\n      positions,\n      glyphIndices,\n      glyphs: glyphRun.glyphs\n    });\n  };\n};\n\n/**\n * Generate glyphs for single attributed string\n */\nconst generateGlyphs = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string with glyphs\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(layoutRun(attributedString.string));\n    return Object.assign({}, attributedString, {\n      runs\n    });\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Resolves yOffset for run\n *\n * @param {Run} run run\n * @returns {Run} run\n */\nconst resolveRunYOffset = run => {\n  var _run$attributes, _run$attributes$font, _run$attributes2;\n  if (!run.positions) return run;\n  const unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;\n  const yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;\n  const positions = run.positions.map(p => Object.assign({}, p, {\n    yOffset\n  }));\n  return Object.assign({}, run, {\n    positions\n  });\n};\n\n/**\n * Resolves yOffset for multiple paragraphs\n */\nconst resolveYOffset = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(resolveRunYOffset);\n    return Object.assign({}, attributedString, {\n      runs\n    });\n  };\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Sort runs in ascending order\n *\n * @param {Run[]} runs\n * @returns {Run[]} sorted runs\n */\nconst sort = runs => {\n  return runs.sort((a, b) => a.start - b.start || a.end - b.end);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Is run empty (start === end)\n *\n * @param {Run} run run\n * @returns {boolean} is run empty\n */\nconst isEmpty = run => {\n  return run.start === run.end;\n};\n\n/**\n * @typedef {import('../types.js').Point} Point\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Sort points in ascending order\n * @param {Point} a first point\n * @param {Point} b second point\n * @returns {number} sort order\n */\nconst sortPoints = (a, b) => {\n  return a[1] - b[1] || a[3] - b[3];\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Point[]} points\n */\nconst generatePoints = runs => {\n  const result = runs.reduce((acc, run, i) => {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Run} merged runs\n */\nconst mergeRuns = runs => {\n  return runs.reduce((acc, run) => {\n    const attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes\n    });\n  }, {});\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Run[][]} grouped runs\n */\nconst groupEmptyRuns = runs => {\n  const groups = runs.reduce((acc, run) => {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, []);\n  return Object.values(groups);\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Run[]} flattened runs\n */\nconst flattenEmptyRuns = runs => {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Run[]} flattened runs\n */\nconst flattenRegularRuns = runs => {\n  const res = [];\n  const points = generatePoints(runs);\n  let start = -1;\n  let attrs = {};\n  const stack = [];\n  for (let i = 0; i < points.length; i += 1) {\n    const [type, offset, attributes] = points[i];\n    if (start !== -1 && start < offset) {\n      res.push({\n        start,\n        end: offset,\n        attributes: attrs\n      });\n    }\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n      for (let j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          // eslint-disable-next-line no-plusplus\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n    start = offset;\n  }\n  return res;\n};\n\n/**\n * Flatten many runs\n *\n * @param {Run[]} runs\n * @returns {Run[]} flattened runs\n */\nconst flatten = function (runs) {\n  if (runs === void 0) {\n    runs = [];\n  }\n  const emptyRuns = flattenEmptyRuns(runs.filter(run => isEmpty(run)));\n  const regularRuns = flattenRegularRuns(runs.filter(run => !isEmpty(run)));\n  return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\n * Returns empty attributed string\n *\n * @returns {Object} empty attributed string\n */\nconst empty = () => ({\n  string: '',\n  runs: []\n});\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n *\n * @param {AttributedString} attributedString\n * @returns {AttributedString} attributed string without font\n */\nconst omitFont = attributedString => {\n  const runs = attributedString.runs.map(run => omit('font', run));\n  return Object.assign({}, attributedString, {\n    runs\n  });\n};\n\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n */\nconst preprocessRuns = (engines, options) => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} processed attributed string\n   */\n  return attributedString => {\n    if (isNil(attributedString)) return empty();\n    const {\n      string\n    } = attributedString;\n    const {\n      fontSubstitution,\n      scriptItemizer,\n      bidi\n    } = engines;\n    const {\n      runs: omittedFontRuns\n    } = omitFont(attributedString);\n    const {\n      runs: itemizationRuns\n    } = scriptItemizer(options)(attributedString);\n    const {\n      runs: substitutedRuns\n    } = fontSubstitution(options)(attributedString);\n    const {\n      runs: bidiRuns\n    } = bidi(options)(attributedString);\n    const runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string,\n      runs: flatten(runs)\n    };\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Breaks attributed string into paragraphs\n */\nconst splitParagraphs = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString[]} attributed string array\n   */\n  return attributedString => {\n    const res = [];\n    let start = 0;\n    let breakPoint = attributedString.string.indexOf('\\n') + 1;\n    while (breakPoint > 0) {\n      res.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n    if (start === 0) {\n      res.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      res.push(slice(start, length$1(attributedString), attributedString));\n    }\n    return res;\n  };\n};\n\n/**\n * @typedef {import('../types.js').Position} Position\n */\n\n/**\n * Return positions advance width\n *\n * @param {Position[]} positions positions\n * @returns {number} advance width\n */\nconst advanceWidth$2 = positions => {\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Return run advance width\n *\n * @param {Run} run run\n * @returns {number} advance width\n */\nconst advanceWidth$1 = run => {\n  return advanceWidth$2(run.positions || []);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Returns attributed string advancewidth\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} advance width\n */\nconst advanceWidth = attributedString => {\n  const reducer = (acc, run) => acc + advanceWidth$1(run);\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\nconst WHITE_SPACES_CODE = 32;\n\n/**\n * Check if glyph is white space\n *\n * @param {Glyph} [glyph] glyph\n * @returns {boolean} whether glyph is white space\n * */\nconst isWhiteSpace = glyph => {\n  const codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\n * @typedef {import('../types.js').Position} Position\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get white space leading positions\n *\n * @param {Run} run run\n * @returns {Position[]} white space leading positions\n */\nconst leadingPositions = run => {\n  const glyphs = run.glyphs || [];\n  const positions = run.positions || [];\n  const leadingWhitespaces = glyphs.findIndex(g => !isWhiteSpace(g));\n  return positions.slice(0, leadingWhitespaces);\n};\n\n/**\n * Get run leading white space offset\n *\n * @param {Run} run run\n * @returns {number} leading white space offset\n */\nconst leadingOffset$1 = run => {\n  const positions = leadingPositions(run);\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string leading white space offset\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} leading white space offset\n */\nconst leadingOffset = attributedString => {\n  const runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n\n/**\n * @typedef {import('../types.js').Position} Position\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * @template T\n * @param {T[]} array\n * @returns {T[]} reversed array\n */\nconst reverse = array => {\n  return [...array].reverse();\n};\n\n/**\n * Get white space trailing positions\n *\n * @param {Run} run run\n * @returns {Position[]} white space trailing positions\n */\nconst trailingPositions = run => {\n  const glyphs = reverse(run.glyphs || []);\n  const positions = reverse(run.positions || []);\n  const leadingWhitespaces = glyphs.findIndex(g => !isWhiteSpace(g));\n  return positions.slice(0, leadingWhitespaces);\n};\n\n/**\n * Get run trailing white space offset\n *\n * @param {Run} run run\n * @returns {number} trailing white space offset\n */\nconst trailingOffset$1 = run => {\n  const positions = trailingPositions(run);\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string trailing white space offset\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} trailing white space offset\n */\nconst trailingOffset = attributedString => {\n  const runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Drop last char of run\n *\n * @param {Run} run run\n * @returns {Run} run without last char\n */\nconst dropLast$1 = run => {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Drop last glyph\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string with new glyph\n */\nconst dropLast = attributedString => {\n  const string = dropLast$2(attributedString.string);\n  const runs = adjust(-1, dropLast$1, attributedString.runs);\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\nconst ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n\n/**\n * Remove new line char at the end of line if present\n *\n * @param {Object}  line\n * @returns {Object} line\n */\nconst removeNewLine = line => {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\nconst getOverflowLeft = line => {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\nconst getOverflowRight = line => {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param {Object}  line\n * @returns {Object} line\n */\nconst adjustOverflow = line => {\n  const overflowLeft = getOverflowLeft(line);\n  const overflowRight = getOverflowRight(line);\n  const x = line.box.x - overflowLeft;\n  const width = line.box.width + overflowLeft + overflowRight;\n  const box = Object.assign({}, line.box, {\n    x,\n    width\n  });\n  return Object.assign({}, line, {\n    box,\n    overflowLeft,\n    overflowRight\n  });\n};\n\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n * @param {string} align text align\n */\nconst justifyLine$1 = (engines, options, align) => {\n  /**\n   * @param {Object} line lint\n   * @returns {Object} line\n   */\n  return line => {\n    const lineWidth = advanceWidth(line);\n    const alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    const remainingWidth = Math.max(0, line.box.width - lineWidth);\n    const shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    const x = line.box.x + remainingWidth * alignFactor;\n    const box = Object.assign({}, line.box, {\n      x\n    });\n    const newLine = Object.assign({}, line, {\n      box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\nconst finalizeLine = line => {\n  let lineAscent = 0;\n  let lineDescent = 0;\n  let lineHeight = 0;\n  let lineXAdvance = 0;\n  const runs = line.runs.map(run => {\n    const height = height$1(run);\n    const ascent = ascent$1(run);\n    const descent$1 = descent(run);\n    const xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height,\n      ascent,\n      descent: descent$1,\n      xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n */\nconst finalizeBlock = function (engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n  /**\n   * @param {Object} line lint\n   * @param {number} i line index\n   * @param {Object[]} lines total lines\n   * @returns {Object} line\n   */\n  return (line, i, lines) => {\n    var _line$runs, _line$runs$;\n    const isLastFragment = i === lines.length - 1;\n    const style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    const align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(options), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n */\nconst finalizeFragments = (engines, options) => {\n  /**\n   * @param {Object[]} blocks line blocks\n   * @returns {Object[]} blocks\n   */\n  return blocks => {\n    const blockFinalizer = finalizeBlock(engines, options);\n    return blocks.map(block => block.map(blockFinalizer));\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\nconst ATTACHMENT_CODE = 0xfffc; // 65532\n\nconst isReplaceGlyph = glyph => glyph.codePoints.includes(ATTACHMENT_CODE);\n\n/**\n * Resolve attachments of run\n *\n * @param {Object}  run\n * @returns {Object} run\n */\nconst resolveRunAttachments = run => {\n  var _run$attributes;\n  if (!run.positions) return run;\n  const glyphs = run.glyphs || [];\n  const attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};\n  const positions = run.positions.map((position, i) => {\n    const glyph = glyphs[i];\n    if (attachment && attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions\n  });\n};\n\n/**\n * Resolve attachments for multiple paragraphs\n */\nconst resolveAttachments = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(resolveRunAttachments);\n    return Object.assign({}, attributedString, {\n      runs\n    });\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Attributes} Attributes\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * @param {Attributes} a attributes\n * @returns {Attributes} attributes with defaults\n */\nconst applyAttributes = a => {\n  return {\n    align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    direction: a.direction || 'ltr',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || null,\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    verticalAlign: a.verticalAlign || null,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n\n/**\n * Apply default style to run\n *\n * @param {Run} run run\n * @returns {Run} run with styles\n */\nconst applyRunStyles = run => {\n  const attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes\n  });\n};\n\n/**\n * Apply default attributes for an attributed string\n */\nconst applyDefaultStyles = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const string = attributedString.string || '';\n    const runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string,\n      runs\n    };\n  };\n};\n\n/* eslint-disable no-restricted-syntax */\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n */\nconst verticalAlignment = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    attributedString.runs.forEach(run => {\n      const {\n        attributes\n      } = run;\n      const {\n        verticalAlign\n      } = attributes;\n      if (verticalAlign === 'sub') {\n        attributes.yOffset = -0.2;\n      } else if (verticalAlign === 'super') {\n        attributes.yOffset = 0.4;\n      }\n    });\n    return attributedString;\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Run} Run\n */\n\nconst bidi$1 = bidiFactory();\n\n/**\n * @param {Run[]} runs\n * @returns {number[]} bidi levels\n */\nconst getBidiLevels = runs => {\n  return runs.reduce((acc, run) => {\n    const length = run.end - run.start;\n    const levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\n\n/**\n * Perform bidi mirroring\n */\nconst mirrorString = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const levels = getBidiLevels(attributedString.runs);\n    let updatedString = '';\n    attributedString.string.split('').forEach((char, index) => {\n      const isRTL = levels[index] % 2 === 1;\n      const mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index)) : null;\n      updatedString += mirroredChar || char;\n    });\n    return _objectSpread(_objectSpread({}, attributedString), {}, {\n      string: updatedString,\n      levels\n    });\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n *\n * @param {Object} engines engines\n */\nconst layoutEngine = engines => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @param {Rect} container container rect\n   * @param {Object} options layout options\n   * @returns {Object[]} paragraph blocks\n   */\n  return function (attributedString, container, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines, options));\n    const processParagraphs = paragraphs => paragraphs.map(processParagraph);\n    return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n  };\n};\nconst bidi = bidiFactory();\n\n/**\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\nconst bidiEngine = () => attributedString => {\n  var _attributedString$run;\n  const {\n    string\n  } = attributedString;\n  const direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\n  const {\n    levels\n  } = bidi.getEmbeddingLevels(string, direction);\n  let lastLevel = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n  for (let i = 0; i < levels.length; i += 1) {\n    const level = levels[i];\n    if (level !== lastLevel) {\n      if (lastLevel !== null) {\n        res.push({\n          start: lastIndex,\n          end: index,\n          attributes: {\n            bidiLevel: lastLevel\n          }\n        });\n      }\n      lastIndex = index;\n      lastLevel = level;\n    }\n    index += 1;\n  }\n  if (lastIndex < string.length) {\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        bidiLevel: lastLevel\n      }\n    });\n  }\n  return {\n    string,\n    runs: res\n  };\n};\n\n/* eslint-disable no-plusplus */\nconst INFINITY = 10000;\n\n/**\n * @param {Object[]} subnodes\n * @param {number[]} widths\n * @param {number} lineNumber\n * @returns {number}\n */\nconst getNextBreakpoint = (subnodes, widths, lineNumber) => {\n  let position = null;\n  let minimumBadness = Infinity;\n  const sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  const lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n  const calculateRatio = node => {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n    return 0;\n  };\n  for (let i = 0; i < subnodes.length; i += 1) {\n    const node = subnodes[i];\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        let j = i === 0 ? i + 1 : i;\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n        position = j - 1;\n      }\n      break;\n    }\n    if (node.type === 'penalty' || node.type === 'glue') {\n      const ratio = calculateRatio(node);\n      const penalty = node.type === 'penalty' ? node.penalty : 0;\n      const badness = 100 * Math.abs(ratio) ** 3 + penalty;\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\n/**\n * @param {Object[]} nodes\n * @param {number[]} widths\n */\nconst applyBestFit = (nodes, widths) => {\n  let count = 0;\n  let lineNumber = 0;\n  let subnodes = nodes;\n  const breakpoints = [{\n    position: 0\n  }];\n  while (subnodes.length > 0) {\n    const breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n  return breakpoints;\n};\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\nclass Node {\n  constructor(data) {\n    this.prev = null;\n    this.next = null;\n    this.data = data;\n  }\n  toString() {\n    return this.data.toString();\n  }\n}\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n    this.listLength = 0;\n  }\n  isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  }\n  size() {\n    return this.listSize;\n  }\n  isEmpty() {\n    return this.listSize === 0;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.last;\n  }\n  toString() {\n    return this.toArray().toString();\n  }\n  toArray() {\n    let node = this.head;\n    const result = [];\n    while (node !== null) {\n      result.push(node);\n      node = node.next;\n    }\n    return result;\n  }\n  forEach(fun) {\n    let node = this.head;\n    while (node !== null) {\n      fun(node);\n      node = node.next;\n    }\n  }\n  contains(n) {\n    let node = this.head;\n    if (!this.isLinked(n)) {\n      return false;\n    }\n    while (node !== null) {\n      if (node === n) {\n        return true;\n      }\n      node = node.next;\n    }\n    return false;\n  }\n  at(i) {\n    let node = this.head;\n    let index = 0;\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n      node = node.next;\n      index += 1;\n    }\n    return null;\n  }\n  insertAfter(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  }\n  insertBefore(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  }\n  push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n    return this;\n  }\n  unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n    return this;\n  }\n  remove(node) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n    this.listSize -= 1;\n    return this;\n  }\n  pop() {\n    const node = this.tail;\n    this.tail.prev.next = null;\n    this.tail = this.tail.prev;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  }\n  shift() {\n    const node = this.head;\n    this.head.next.prev = null;\n    this.head = this.head.next;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  }\n}\nLinkedList.Node = Node;\n\n/* eslint-disable no-restricted-properties */\n\n/**\n * @param {Object[]} nodes\n * @param {number[]} lines\n * @param {Object} settings\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\nconst linebreak = (nodes, lines, settings) => {\n  const options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  const activeNodes = new LinkedList();\n  const sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  const lineLengths = lines;\n  const breaks = [];\n  let tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position,\n      demerits,\n      ratio,\n      line,\n      fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous\n    };\n  }\n  function computeCost(start, end, active, currentLine) {\n    let width = sum.width - active.totals.width;\n    let stretch = 0;\n    let shrink = 0;\n    // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n    const lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n      return linebreak.infinity;\n    }\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n      return linebreak.infinity;\n    }\n\n    // perfect match\n    return 0;\n  }\n\n  // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n  function computeSum(breakPointIndex) {\n    const result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n    for (let i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n    return result;\n  }\n\n  // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n  function mainLoop(node, index, nodes) {\n    let active = activeNodes.first();\n    let next = null;\n    let ratio = 0;\n    let demerits = 0;\n    /**\n     * @type {Object[]}\n     */\n    let candidates = [];\n    let badness;\n    let currentLine = 0;\n    let tmpSum;\n    let currentClass = 0;\n    let fitnessClass;\n    /**\n     * @type {Object}\n     */\n    let candidate;\n    let newNode;\n\n    // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }];\n\n      // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine);\n\n        // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        }\n\n        // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3);\n\n          // Positive penalty\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);\n            // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);\n            // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          }\n\n          // Calculate the fitness class for this candidate active node.\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          }\n\n          // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          }\n\n          // Add the total demerits of the active node to get the total demerits of this candidate node.\n          demerits += active.data.demerits;\n\n          // Only store the best candidate for each fitness class\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active,\n              demerits,\n              ratio\n            };\n          }\n        }\n        active = next;\n\n        // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n      tmpSum = computeSum(index);\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n        if (candidate.demerits < Infinity) {\n          newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  }\n\n  // Add an active node for the start of the paragraph.\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, undefined, null)));\n\n  // eslint-disable-next-line no-shadow\n  nodes.forEach((node, index, nodes) => {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(node => {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n    return breaks.reverse();\n  }\n  return [];\n};\nlinebreak.infinity = 10000;\nlinebreak.glue = (width, value, stretch, shrink) => ({\n  type: 'glue',\n  value,\n  width,\n  stretch,\n  shrink\n});\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n  return {\n    type: 'box',\n    width,\n    value,\n    hyphenated\n  };\n};\nlinebreak.penalty = (width, penalty, flagged) => ({\n  type: 'penalty',\n  width,\n  penalty,\n  flagged\n});\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Add scalar to run\n *\n * @param {number} n scalar\n * @param {Run} run run\n * @returns {Run} added run\n */\nconst add = (n, run) => {\n  const start = run.start + n;\n  const end = run.end + n;\n  return Object.assign({}, run, {\n    start,\n    end\n  });\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run length\n *\n * @param {Run} run run\n * @returns {number} length\n */\nconst length = run => {\n  return run.end - run.start;\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Concats two runs into one\n *\n * @param {Run} runA first run\n * @param {Run} runB second run\n * @returns {Run} concatenated run\n */\nconst concat = (runA, runB) => {\n  const end = runA.end + length(runB);\n  const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  const positions = (runA.positions || []).concat(runB.positions || []);\n  const attributes = Object.assign({}, runA.attributes, runB.attributes);\n  const runAIndices = runA.glyphIndices || [];\n  const runALastIndex = last(runAIndices) || 0;\n  const runBIndices = (runB.glyphIndices || []).map(i => i + runALastIndex + 1);\n  const glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end,\n    glyphs,\n    positions,\n    attributes,\n    glyphIndices\n  });\n};\n\n/**\n * @typedef {import('../types.js').Glyph} Glyph\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Insert glyph to run in the given index\n *\n * @param {number} index index\n * @param {Glyph} glyph glyph\n * @param {Run} run run\n * @returns {Run} run with glyph\n */\nconst insertGlyph$1 = (index, glyph, run) => {\n  if (!glyph) return run;\n\n  // Split resolves ligature splitting in case new glyph breaks some\n  const leadingRun = slice$1(0, index, run);\n  const trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param {number} index index\n * @param {Glyph | number} value glyph or codePoint\n * @param {Run} run run\n * @returns {Run} run with glyph\n */\nconst insert = (index, value, run) => {\n  const font = getFont(run);\n  const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get run index at char index\n *\n * @param {number} n char index\n * @param {AttributedString} string attributed string\n * @returns {number} run index\n */\nconst runIndexAt = (n, string) => {\n  return runIndexAt$1(n, string.runs);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\n/**\n * Insert glyph into attributed string\n *\n * @param {number} index index\n * @param {Glyph} glyph glyph\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string with new glyph\n */\nconst insertGlyph = (index, glyph, attributedString) => {\n  const runIndex = runIndexAt(index, attributedString);\n\n  // Add glyph to the end if run index invalid\n  if (runIndex === -1) return append(glyph, attributedString);\n  const codePoints = glyph.codePoints || [];\n  const string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  const runs = attributedString.runs.map((run, i) => {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Advance width between two string indices\n *\n * @param {number} start glyph index\n * @param {number} end glyph index\n * @param {Run} run run\n * @returns {number} advanced width run\n */\nconst advanceWidthBetween$1 = (start, end, run) => {\n  const runStart = run.start || 0;\n  const glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  const glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param {number} start offset\n * @param {number} end offset\n * @param {AttributedString} attributedString\n * @returns {number} advance width\n */\nconst advanceWidthBetween = (start, end, attributedString) => {\n  const runs = filter(start, end, attributedString.runs);\n  return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start, end, run), 0);\n};\n\n/**\n * @typedef {import('../../types.js').AttributedString} AttributedString\n * @typedef {import('../../types.js').Attributes} Attributes\n */\n\nconst HYPHEN = 0x002d;\nconst TOLERANCE_STEPS = 5;\nconst TOLERANCE_LIMIT = 50;\nconst opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n\n/**\n * Slice attributed string to many lines\n *\n * @param {AttributedString} string attributed string\n * @param {Object[]} nodes\n * @param {Object[]} breaks\n * @returns {AttributedString[]} attributed strings\n */\nconst breakLines = (string, nodes, breaks) => {\n  let start = 0;\n  let end = null;\n  const lines = breaks.reduce((acc, breakPoint) => {\n    const node = nodes[breakPoint.position];\n    const prevNode = nodes[breakPoint.position - 1];\n\n    // Last breakpoint corresponds to K&P mandatory final glue\n    if (breakPoint.position === nodes.length - 1) return acc;\n    let line;\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = slice(start, end, string);\n      line = insertGlyph(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = slice(start, end, string);\n    }\n    start = end;\n    return [...acc, line];\n  }, []);\n\n  // Last line\n  lines.push(slice(start, string.string.length, string));\n  return lines;\n};\n\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {AttributedString} attributedString attributed string\n * @param {Object} args attributed string args\n * @param {Object} options layout options\n * @returns {Object[]} attributed strings\n */\nconst getNodes = (attributedString, _ref, options) => {\n  let {\n    align\n  } = _ref;\n  let start = 0;\n  const hyphenWidth = 5;\n  const {\n    syllables\n  } = attributedString;\n  const hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  const result = syllables.reduce((acc, s, index) => {\n    const width = advanceWidthBetween(start, start + s.length, attributedString);\n    if (s.trim() === '') {\n      const stretch = width * opts.width / opts.stretch;\n      const shrink = width * opts.width / opts.shrink;\n      const value = {\n        start,\n        end: start + s.length\n      };\n      acc.push(linebreak.glue(width, value, stretch, shrink));\n    } else {\n      const hyphenated = syllables[index + 1] !== ' ';\n      const value = {\n        start,\n        end: start + s.length\n      };\n      acc.push(linebreak.box(width, value, hyphenated));\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(linebreak.glue(0, null, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n\n/**\n * @param {AttributedString} attributedString attributed string\n * @returns {Attributes} styles\n */\nconst getStyles = attributedString => {\n  var _attributedString$run, _attributedString$run2;\n  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\n};\n\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param {Object} options layout options\n */\nconst linebreaker = options => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @param {number[]} availableWidths available widths\n   * @returns {AttributedString[]} attributed strings\n   */\n  return (attributedString, availableWidths) => {\n    let tolerance = options.tolerance || 4;\n    const style = getStyles(attributedString);\n    const nodes = getNodes(attributedString, style, options);\n\n    /** @type {Object[]} */\n    let breaks = linebreak(nodes, availableWidths, {\n      tolerance\n    });\n\n    // Try again with a higher tolerance if the line breaking failed.\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, {\n        tolerance\n      });\n    }\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\nconst WHITESPACE_PRIORITY = 1;\nconst LETTER_PRIORITY = 2;\nconst EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nconst EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nconst SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nconst SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nconst getCharFactor = (direction, options) => {\n  const expandCharFactor = options.expandCharFactor || {};\n  const shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\nconst getWhitespaceFactor = (direction, options) => {\n  const expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  const shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\nconst factor = (direction, options) => glyphs => {\n  const charFactor = getCharFactor(direction, options);\n  const whitespaceFactor = getWhitespaceFactor(direction, options);\n  const factors = [];\n  for (let index = 0; index < glyphs.length; index += 1) {\n    let f;\n    const glyph = glyphs[index];\n    if (isWhiteSpace(glyph)) {\n      f = Object.assign({}, whitespaceFactor);\n      if (index === glyphs.length - 1) {\n        f.before = 0;\n        if (index > 0) {\n          factors[index - 1].after = 0;\n        }\n      }\n    } else if (glyph.isMark && index > 0) {\n      f = Object.assign({}, factors[index - 1]);\n      f.before = 0;\n      factors[index - 1].after = 0;\n    } else {\n      f = Object.assign({}, charFactor);\n    }\n    factors.push(f);\n  }\n  return factors;\n};\nconst getFactors = (gap, line, options) => {\n  const direction = gap > 0 ? 'GROW' : 'SHRINK';\n  const getFactor = factor(direction, options);\n  const factors = line.runs.reduce((acc, run) => {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n\n/* eslint-disable no-multi-assign */\nconst KASHIDA_PRIORITY = 0;\nconst NULL_PRIORITY = 3;\nconst getDistances = (gap, factors) => {\n  let total = 0;\n  const priorities = [];\n  const unconstrained = [];\n  for (let priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    priorities[priority] = unconstrained[priority] = 0;\n  }\n\n  // sum the factors at each priority\n  for (let j = 0; j < factors.length; j += 1) {\n    const f = factors[j];\n    const sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  }\n\n  // choose the priorities that need to be applied\n  let highestPriority = -1;\n  let highestPrioritySum = 0;\n  let remainingGap = gap;\n  let priority;\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    const prioritySum = priorities[priority];\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      }\n\n      // if this priority covers the remaining gap, we're done\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      }\n\n      // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n      priorities[priority] = 1;\n      remainingGap -= prioritySum;\n\n      // if this priority has unconstrained glyphs, let them consume the remaining space\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  }\n\n  // zero out remaining priorities (if any)\n  for (let p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  }\n\n  // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  }\n\n  // create and return an array of distances to add to each glyph's advance\n  const distances = [];\n  for (let index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    const f = factors[index];\n    const next = factors[index + 1];\n    let dist = f.after * priorities[f.priority];\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    }\n\n    // if this glyph is unconstrained, add the unconstrained distance as well\n    if (f.unconstrained) {\n      dist += f.after * unconstrained[f.priority];\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n    distances.push(dist);\n  }\n  return distances;\n};\n\n/* eslint-disable consistent-return */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-restricted-syntax */\n\n/**\n * Adjust run positions by given distances\n *\n * @param {number[]} distances\n * @param {Object} line\n * @returns {Object} line\n */\nconst justifyLine = (distances, line) => {\n  let index = 0;\n  for (const run of line.runs) {\n    for (const position of run.positions) {\n      position.xAdvance += distances[index++];\n    }\n  }\n  return line;\n};\n\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * // TODO: Make it immutable\n *\n * @param {Object} options layout options\n */\nconst justification = options => {\n  /**\n   * @param {Object} line\n   * @returns {Object} line\n   */\n  return line => {\n    const gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return; // Exact fit\n\n    const factors = getFactors(gap, line, options);\n    const distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Returns attributed string ascent\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} ascent\n */\nconst ascent = attributedString => {\n  const reducer = (acc, run) => Math.max(acc, ascent$1(run));\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/* eslint-disable no-param-reassign */\n\n// The base font size used for calculating underline thickness.\nconst BASE_FONT_SIZE = 12;\n\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\nconst textDecoration = () => lineFragment => {\n  let x = lineFragment.overflowLeft || 0;\n  const overflowRight = lineFragment.overflowRight || 0;\n  const maxX = advanceWidth(lineFragment) - overflowRight;\n  lineFragment.decorationLines = [];\n  for (let i = 0; i < lineFragment.runs.length; i += 1) {\n    const run = lineFragment.runs[i];\n    const width = Math.min(maxX - x, advanceWidth$1(run));\n    const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n    if (run.attributes.underline) {\n      const rect = {\n        x,\n        y: ascent(lineFragment) + thickness * 2,\n        width,\n        height: thickness\n      };\n      const line = {\n        rect,\n        opacity: run.attributes.opacity,\n        color: run.attributes.underlineColor || 'black',\n        style: run.attributes.underlineStyle || 'solid'\n      };\n      lineFragment.decorationLines.push(line);\n    }\n    if (run.attributes.strike) {\n      const y = ascent(lineFragment) - ascent$1(run) / 3;\n      const rect = {\n        x,\n        y,\n        width,\n        height: thickness\n      };\n      const line = {\n        rect,\n        opacity: run.attributes.opacity,\n        color: run.attributes.strikeColor || 'black',\n        style: run.attributes.strikeStyle || 'solid'\n      };\n      lineFragment.decorationLines.push(line);\n    }\n    x += width;\n  }\n  return lineFragment;\n};\nconst ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n\n/**\n * @typedef {import('../../types.js').AttributedString} AttributedString\n */\n\n/**\n * Resolves unicode script in runs, grouping equal runs together\n */\nconst scriptItemizer = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const {\n      string\n    } = attributedString;\n    let lastScript = 'Unknown';\n    let lastIndex = 0;\n    let index = 0;\n    const res = [];\n    if (!string) return empty();\n    for (let i = 0; i < string.length; i += 1) {\n      const char = string[i];\n      const codePoint = char.codePointAt();\n      const script = unicode.getScript(codePoint);\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n        lastIndex = index;\n        lastScript = script;\n      }\n      index += char.length;\n    }\n    if (lastIndex < string.length) {\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n    return {\n      string,\n      runs: res\n    };\n  };\n};\nconst SOFT_HYPHEN = '\\u00ad';\nconst hyphenator = hyphen(pattern);\n\n/**\n * @param {string} word\n * @returns {string[]} word parts\n */\nconst splitHyphen = word => {\n  return word.split(SOFT_HYPHEN);\n};\nconst cache = {};\n\n/**\n * @param {string} word\n * @returns {string[]} word parts\n */\nconst getParts = word => {\n  const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\nconst wordHyphenation = () => {\n  /**\n   * @param {string} word word\n   * @returns {string[]} word parts\n   */\n  return word => {\n    const cacheKey = \"_\".concat(word);\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\n/* eslint-disable no-restricted-syntax */\n\n/**\n * @typedef {import('../../types.js').AttributedString} AttributedString\n * @typedef {import('../../types.js').Run} Run\n */\n\n/**\n * @param {Run} run run\n * @returns {number}\n */\nconst getFontSize = run => {\n  return run.attributes.fontSize || 12;\n};\n\n/**\n * Resolve font runs in an AttributedString, grouping equal\n * runs and performing font substitution where necessary.\n */\nconst fontSubstitution = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const {\n      string,\n      runs\n    } = attributedString;\n    let lastFont = null;\n    let lastIndex = 0;\n    let index = 0;\n    const res = [];\n    if (!string) return empty();\n    for (const run of runs) {\n      const fontSize = getFontSize(run);\n      const defaultFont = run.attributes.font;\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n      for (const char of string.slice(run.start, run.end)) {\n        const font = defaultFont;\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n          lastFont = font;\n          lastIndex = index;\n        }\n        index += char.length;\n      }\n    }\n    if (lastIndex < string.length) {\n      const fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n    return {\n      string,\n      runs: res\n    };\n  };\n};\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };","map":{"version":3,"names":["isNil","last","repeat","dropLast","dropLast$2","adjust","compose","bidiFactory","unicode","hyphen","pattern","fromFragments","fragments","offset","string","runs","forEach","fragment","push","_objectSpread","start","end","length","attributes","defaultHyphenationEngine","word","wrapWords","engines","options","attributedString","_engines$wordHyphenat","_engines","syllables","hyphenateWord","hyphenationCallback","wordHyphenation","call","i","run","words","slice","split","filter","Boolean","j","parts","join","copy","rect","Object","assign","partition","height","a","b","y","crop","result","height$2","paragraph","reduce","acc","block","box","calculateScale","_attributes$font","fontSize","unitsPerEm","font","scale","_run$attributes","index","glyphIndices","value","getFont","slice$2","glyph","codePoints","String","fromCodePoint","layout","undefined","glyphs","glyphIndexAt","_run$glyphIndices","normalize","array","head","map","slice$1","_run$glyphs","_run$glyphs2","runScale","startIndex","endIndex","startGlyph","endGlyph","startOffset","startGlyphs","Infinity","endOffset","endGlyphs","sliceStart","Math","min","glyphPosition","g","xAdvance","advanceWidth","startPositions","positions","endPositions","flat","runIndexAt$1","n","findIndex","max","subtract","sliceRuns","sliceFirstRun","sliceLastRun","isFirst","isLast","filteredRuns","slicedRuns","findCharIndex","search","findLastCharIndex","match","lastIndexOf","trim","empty$1","isNumber","appendIndices","indices","lastIndex","newIndices","Array","fill","concat","glyphForCodePoint","appendGlyph","_glyph$codePoints","glyphLength","append$1","stringFromCodePoints","append","codePointsString","firstRuns","lastRun","ELLIPSIS_UNICODE","ELLIPSIS_STRING","fromCharCode","getEllipsisCodePoint","encode","parseInt","truncate","_last","_last2","_last2$attributes","codePoint","lastBlock","omit","ascent$1","_run$attributes$attac","_run$attributes2","_run$attributes2$font","attachmentHeight","attachment","fontAscent","ascent","descent","_run$attributes$font","fontDescent","lineGap","height$1","lineHeight","reducer","intersects","x","num1","width","num2","getLineFragment","lineRect","excludeRect","eStart","eEnd","lStart","lEnd","r","getLineFragments","excludeRects","pieces","generateLineRects","container","_objectWithoutProperties","_excluded","lineRects","maxY","currentRect","rest","lineRectFragments","ATTACHMENT_CODE$1","purgeAttachments","shouldPurge","includes","layoutLines","rects","lines","indent","shift","currentY","line","_line$runs","_line$runs$","lineIndent","style","newLine","layoutParagraph","_paragraph$runs","_paragraph$runs$","_paragraph$runs$$attr","availableWidths","unshift","linebreaker","sliceAtHeight","newBlock","counter","typesetter","attributedStrings","blocks","paragraphs","layoutBlock","maxLines","truncateEllipsis","truncateMode","linesCount","paragraphRect","nextParagraph","slicedBlock","linesHeight","shouldTruncate","length$1","bidi$2","getBidiLevels$1","levels","bidiLevel","getReorderedIndices","segments","_ref","getItemAtIndex","objectName","updatedIndex","Error","reorderLine","_attributedString$run","direction","level","embeddingLevels","getReorderSegments","updatedString","getReorderedString","updatedRuns","selectedIndices","updatedGlyphs","updatedPositions","addedGlyphs","Set","has","id","isLigature","add","reorderParagraph","bidiReordering","DUMMY_CODEPOINT","resolve","next","getCharacterSpacing","characterSpacing","scalePositions","position","xSpacing","yAdvance","xOffset","yOffset","layoutRun","runString","glyphRun","generateGlyphs","resolveRunYOffset","p","resolveYOffset","sort","isEmpty","sortPoints","generatePoints","mergeRuns","groupEmptyRuns","groups","values","flattenEmptyRuns","flattenRegularRuns","res","points","attrs","stack","type","splice","flatten","emptyRuns","regularRuns","empty","omitFont","preprocessRuns","fontSubstitution","scriptItemizer","bidi","omittedFontRuns","itemizationRuns","substitutedRuns","bidiRuns","splitParagraphs","breakPoint","indexOf","advanceWidth$2","pos","advanceWidth$1","WHITE_SPACES_CODE","isWhiteSpace","leadingPositions","leadingWhitespaces","leadingOffset$1","leadingOffset","reverse","trailingPositions","trailingOffset$1","trailingOffset","dropLast$1","ALIGNMENT_FACTORS","center","right","removeNewLine","getOverflowLeft","overflowLeft","getOverflowRight","overflowRight","adjustOverflow","justifyLine$1","align","lineWidth","alignFactor","remainingWidth","shouldJustify","justification","finalizeLine","lineAscent","lineDescent","lineXAdvance","descent$1","finalizeBlock","isLastFragment","alignLastLine","textDecoration","finalizeFragments","blockFinalizer","ATTACHMENT_CODE","isReplaceGlyph","resolveRunAttachments","resolveAttachments","applyAttributes","backgroundColor","bullet","color","features","hangingPunctuation","hyphenationFactor","justificationFactor","lineSpacing","link","marginLeft","margin","marginRight","opacity","paddingTop","padding","paragraphSpacing","script","shrinkFactor","strike","strikeColor","strikeStyle","stroke","underline","underlineColor","underlineStyle","verticalAlign","wordSpacing","applyRunStyles","applyDefaultStyles","verticalAlignment","bidi$1","getBidiLevels","mirrorString","char","isRTL","mirroredChar","getMirroredCharacter","charAt","layoutEngine","processParagraph","processParagraphs","bidiEngine","getEmbeddingLevels","lastLevel","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","minimumBadness","sum","stretch","shrink","lineLength","calculateRatio","node","ratio","penalty","badness","abs","applyBestFit","nodes","count","breakpoints","breakpoint","Node","constructor","data","prev","toString","LinkedList","tail","listSize","listLength","isLinked","size","first","toArray","fun","contains","at","insertAfter","newNode","insertBefore","remove","pop","linebreak","settings","demerits","flagged","fitness","tolerance","activeNodes","lineLengths","breaks","tmp","fitnessClass","totals","previous","computeCost","active","currentLine","infinity","computeSum","breakPointIndex","mainLoop","candidates","tmpSum","currentClass","candidate","pow","glue","hyphenated","runA","runB","runAIndices","runALastIndex","runBIndices","insertGlyph$1","leadingRun","trailingRun","insert","runIndexAt","insertGlyph","runIndex","advanceWidthBetween$1","runStart","glyphStartIndex","glyphEndIndex","advanceWidthBetween","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","breakLines","prevNode","getNodes","hyphenWidth","hyphenPenalty","hyphenationPenalty","s","getStyles","_attributedString$run2","WHITESPACE_PRIORITY","LETTER_PRIORITY","EXPAND_WHITESPACE_FACTOR","before","after","priority","unconstrained","EXPAND_CHAR_FACTOR","SHRINK_WHITESPACE_FACTOR","SHRINK_CHAR_FACTOR","getCharFactor","expandCharFactor","shrinkCharFactor","getWhitespaceFactor","expandWhitespaceFactor","shrinkWhitespaceFactor","factor","charFactor","whitespaceFactor","factors","f","isMark","getFactors","gap","getFactor","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","total","priorities","highestPriority","highestPrioritySum","remainingGap","prioritySum","distances","dist","justifyLine","BASE_FONT_SIZE","lineFragment","maxX","decorationLines","thickness","floor","ignoredScripts","lastScript","codePointAt","getScript","SOFT_HYPHEN","hyphenator","splitHyphen","cache","getParts","base","cacheKey","getFontSize","lastFont","defaultFont","default"],"sources":["/home/sofiane/Desktop/Crop Nutrition Optimizer/frontend/node_modules/@react-pdf/textkit/lib/textkit.js"],"sourcesContent":["import { isNil, last, repeat, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport bidiFactory from 'bidi-js';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us.js';\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Fragment} Fragment\n */\n\n/**\n * Create attributed string from text fragments\n *\n * @param {Fragment[]} fragments fragments\n * @returns {AttributedString} attributed string\n */\nconst fromFragments = fragments => {\n  let offset = 0;\n  let string = '';\n  const runs = [];\n  fragments.forEach(fragment => {\n    string += fragment.string;\n    runs.push({\n      ...fragment,\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string,\n    runs\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Default word hyphenation engine used when no one provided.\n * Does not perform word hyphenation at all\n *\n * @param {string} word\n * @returns {[string]} same word\n */\nconst defaultHyphenationEngine = word => [word];\n\n/**\n * Wrap words of attribute string\n *\n * @param {Object} engines layout engines\n * @param {Object} options layout options\n */\nconst wrapWords = function (engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n  if (options === void 0) {\n    options = {};\n  }\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string including syllables\n   */\n  return attributedString => {\n    var _engines$wordHyphenat, _engines;\n    const syllables = [];\n    const fragments = [];\n    const hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;\n    for (let i = 0; i < attributedString.runs.length; i += 1) {\n      let string = '';\n      const run = attributedString.runs[i];\n      const words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n      for (let j = 0; j < words.length; j += 1) {\n        const word = words[j];\n        const parts = hyphenateWord(word);\n        syllables.push(...parts);\n        string += parts.join('');\n      }\n      fragments.push({\n        ...run,\n        string\n      });\n    }\n    return {\n      ...fromFragments(fragments),\n      syllables\n    };\n  };\n};\n\n/**\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Clone rect\n *\n * @param {Rect} rect rect\n * @returns {Rect} cloned rect\n */\nconst copy = rect => {\n  return Object.assign({}, rect);\n};\n\n/**\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n *\n * @param {Rect} rect rect\n * @param {number} height height\n * @returns {[Rect, Rect]} partitioned rects\n */\nconst partition = (rect, height) => {\n  const a = Object.assign({}, rect, {\n    height\n  });\n  const b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n\n/**\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Crop upper section of rect\n *\n * @param {number} height height\n * @param {Rect} rect rect\n * @returns {Rect} cropped rect\n */\nconst crop = (height, rect) => {\n  const [, result] = partition(rect, height);\n  return result;\n};\n\n/**\n * Get paragraph block height\n *\n * @param {Object}  paragraph block\n * @returns {number} paragraph block height\n */\nconst height$2 = paragraph => {\n  return paragraph.reduce((acc, block) => acc + block.box.height, 0);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Calculate run scale\n *\n * @param {Run} run run\n * @returns {number} scale\n */\nconst calculateScale = run => {\n  var _attributes$font;\n  const attributes = run.attributes || {};\n  const fontSize = attributes.fontSize || 12;\n  const unitsPerEm = (_attributes$font = attributes.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n\n/**\n * Get run scale\n *\n * @param {Object}  run\n * @returns {number} scale\n */\nconst scale = run => {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get ligature offset by index\n *\n * Ex. ffi ligature\n *\n *   glyphs:         l  o  f  f  i  m\n *   glyphIndices:   0  1  2  2  2  3\n *   offset:         0  0  0  1  2  0\n *\n * @param {number} index\n * @param {Run} run run\n * @returns {number} ligature offset\n */\nconst offset = (index, run) => {\n  if (!run) return 0;\n  const glyphIndices = run.glyphIndices || [];\n  const value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(i => i === value).length;\n};\n\n/**\n * @typedef {import('../types.js').Font} Font\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run font\n *\n * @param {Run} run run\n * @returns {Font | null} font\n */\nconst getFont = run => {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;\n};\n\n/**\n * @typedef {import('../types.js').Font} Font\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\n/**\n * Slice glyph between codePoints range\n * Util for breaking ligatures\n *\n * @param {number} start start code point index\n * @param {number} end end code point index\n * @param {Font} font font to generate new glyph\n * @param {Glyph} glyph glyph to be sliced\n * @returns {Glyph[]} sliced glyph parts\n */\nconst slice$2 = (start, end, font, glyph) => {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  const codePoints = glyph.codePoints.slice(start, end);\n  const string = String.fromCodePoint(...codePoints);\n\n  // passing LTR To force fontkit to not reverse the string\n  return font ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs : [glyph];\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Return glyph index at string index, if glyph indices present.\n * Otherwise return string index\n *\n * @param {number} index index\n * @param {Run} run run\n * @returns {number} glyph index\n */\nconst glyphIndexAt = (index, run) => {\n  var _run$glyphIndices;\n  const result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index];\n  return isNil(result) ? index : result;\n};\n\n/**\n * Returns new array starting with zero, and keeping same relation between consecutive values\n *\n * @param {number[]} array list\n * @returns {number[]} normalized array\n */\nconst normalize = array => {\n  const head = array[0];\n  return array.map(value => value - head);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Slice run between glyph indices range\n *\n * @param {number} start glyph index\n * @param {number} end glyph index\n * @param {Run} run run\n * @returns {Run} sliced run\n */\nconst slice$1 = (start, end, run) => {\n  var _run$glyphs, _run$glyphs2;\n  const runScale = scale(run);\n  const font = getFont(run);\n\n  // Get glyph start and end indices\n  const startIndex = glyphIndexAt(start, run);\n  const endIndex = glyphIndexAt(end, run);\n\n  // Get start and end glyph\n  const startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];\n  const endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex];\n\n  // Get start ligature chunks (if any)\n  const startOffset = offset(start, run);\n  const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\n\n  // Get end ligature chunks (if any)\n  const endOffset = offset(end, run);\n  const endGlyphs = slice$2(0, endOffset, font, endGlyph);\n\n  // Compute new glyphs\n  const sliceStart = startIndex + Math.min(1, startOffset);\n  const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\n\n  // Compute new positions\n  const glyphPosition = g => ({\n    xAdvance: g.advanceWidth * runScale\n  });\n  const startPositions = startGlyphs.map(glyphPosition);\n  const positions = (run.positions || []).slice(sliceStart, endIndex);\n  const endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run index that contains passed index\n *\n * @param {number} n index\n * @param {Run[]} runs runs\n * @returns {number} run index\n */\nconst runIndexAt$1 = (n, runs) => {\n  if (!runs) return -1;\n  return runs.findIndex(run => run.start <= n && n < run.end);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Filter runs contained between start and end\n *\n * @param {number} start\n * @param {number} end\n * @param {Run[]} runs\n * @returns {Run[]} filtered runs\n */\nconst filter = (start, end, runs) => {\n  const startIndex = runIndexAt$1(start, runs);\n  const endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Subtract scalar to run\n *\n * @param {number} n scalar\n * @param {Run} run run\n * @returns {Object} subtracted run\n */\nconst subtract = (n, run) => {\n  const start = run.start - n;\n  const end = run.end - n;\n  return Object.assign({}, run, {\n    start,\n    end\n  });\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Slice array of runs\n *\n * @param {number} start offset\n * @param {number} end offset\n * @param {Run[]} runs\n * @returns {Run[]} sliced runs\n */\nconst sliceRuns = (start, end, runs) => {\n  const sliceFirstRun = a => slice$1(start - a.start, end - a.start, a);\n  const sliceLastRun = a => slice$1(0, end - a.start, a);\n  return runs.map((run, i) => {\n    let result = run;\n    const isFirst = i === 0;\n    const isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n\n/**\n * Slice attributed string between two indices\n *\n * @param {number} start offset\n * @param {number} end offset\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string\n */\nconst slice = (start, end, attributedString) => {\n  if (attributedString.string.length === 0) return attributedString;\n  const string = attributedString.string.slice(start, end);\n  const filteredRuns = filter(start, end, attributedString.runs);\n  const slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string,\n    runs: slicedRuns\n  });\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * @param {string} string\n * @returns {number} index\n */\nconst findCharIndex = string => {\n  return string.search(/\\S/g);\n};\n\n/**\n * @param {string} string\n * @returns {number} index\n */\nconst findLastCharIndex = string => {\n  const match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n\n/**\n * Removes (strips) whitespace from both ends of the attributted string.\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string\n */\nconst trim = attributedString => {\n  const start = findCharIndex(attributedString.string);\n  const end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Returns empty run\n *\n * @returns {Run} empty run\n */\nconst empty$1 = () => {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n\n/**\n * Check if value is a number\n *\n * @template {unknown} T\n * @param {T} value Value to check\n * @returns {value is number} Whether value is a number\n */\nconst isNumber = value => {\n  return typeof value === 'number';\n};\n\n/**\n * Append glyph indices with given length\n *\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\n *\n * @param {number} length length\n * @param {number[]} indices glyph indices\n * @returns {number[]} extended glyph indices\n */\nconst appendIndices = (length, indices) => {\n  const lastIndex = last(indices);\n  const value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  const newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n\n/**\n * @typedef {import('../types.js').Font} Font\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\n/**\n * Get glyph for a given code point\n *\n * @param {number} [value] codePoint\n * @param {Font} [font] font\n * @returns {Glyph} glyph\n * */\nconst fromCodePoint = (value, font) => {\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n\n/**\n * @typedef {import('../types.js').Glyph} Glyph\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Append glyph to run\n *\n * @param {Glyph} glyph glyph\n * @param {Run} run run\n * @returns {Run} run with glyph\n */\nconst appendGlyph = (glyph, run) => {\n  var _glyph$codePoints;\n  const glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;\n  const end = run.end + glyphLength;\n  const glyphs = run.glyphs.concat(glyph);\n  const glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end,\n    glyphs,\n    glyphIndices\n  });\n  const positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run)\n  });\n  return Object.assign({}, run, {\n    end,\n    glyphs,\n    glyphIndices,\n    positions\n  });\n};\n\n/**\n * Append glyph or code point to run\n *\n * @param {Glyph | number | undefined} value glyph or codePoint\n * @param {Run} run run\n * @returns {Run} run with glyph\n */\nconst append$1 = (value, run) => {\n  if (!value) return run;\n  const font = getFont(run);\n  const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n\n/**\n * Get string from array of code points\n *\n * @param {number[]} codePoints points\n * @returns {string} string\n */\nconst stringFromCodePoints = codePoints => {\n  return String.fromCodePoint(...(codePoints || []));\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\n/**\n * Append glyph into last run of attributed string\n *\n * @param {Glyph} glyph glyph\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string with new glyph\n */\nconst append = (glyph, attributedString) => {\n  const codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  const codePointsString = stringFromCodePoints(codePoints);\n  const string = attributedString.string + codePointsString;\n  const firstRuns = attributedString.runs.slice(0, -1);\n  const lastRun = last(attributedString.runs) || empty$1();\n  const runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\n\nconst ELLIPSIS_UNICODE = 8230;\nconst ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n\n/**\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\n *\n * @param {Object} font\n * @returns {Object} ellipsis codepoint\n */\nconst getEllipsisCodePoint = font => {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n  const [codePoints] = font.encode(ELLIPSIS_STRING);\n  return parseInt(codePoints[0], 16);\n};\n\n/**\n * Trucante block with ellipsis\n *\n * @param {Object} block paragraph block\n * @returns {Object} sliced paragraph block\n */\nconst truncate = block => {\n  var _last, _last2, _last2$attributes;\n  const runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];\n  const font = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;\n  if (font) {\n    const index = block.length - 1;\n    const codePoint = getEllipsisCodePoint(font);\n    const glyph = font.glyphForCodePoint(codePoint);\n    const lastBlock = append(glyph, trim(block[index]));\n    return Object.assign([], block, {\n      [index]: lastBlock\n    });\n  }\n  return block;\n};\n\n/**\n * @typedef {import('../types.js').Attributes} Attributes\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Omit attribute from run\n *\n * @param {keyof Attributes} value attribute value\n * @param {Run} run run\n * @returns {Run} run without ommited attribute\n */\nconst omit = (value, run) => {\n  const attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes\n  });\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run ascent\n *\n * @param {Run} run run\n * @returns {number} ascent\n */\nconst ascent$1 = run => {\n  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;\n  const attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;\n  const fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run descent\n *\n * @param {Run} run run\n * @returns {number} descent\n */\nconst descent = run => {\n  var _run$attributes, _run$attributes$font;\n  const fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;\n  return scale(run) * fontDescent;\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run lineGap\n *\n * @param {Object} run run\n * @returns {number} lineGap\n */\nconst lineGap = run => {\n  var _run$attributes, _run$attributes$font;\n  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale(run);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run height\n *\n * @param {Run} run run\n * @returns {number} height\n */\nconst height$1 = run => {\n  var _run$attributes;\n  const lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Returns attributed string height\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} height\n */\nconst height = attributedString => {\n  const reducer = (acc, run) => Math.max(acc, height$1(run));\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Checks if two rects intersect each other\n *\n * @param {Rect} a rect A\n * @param {Rect} b rect B\n * @returns {boolean} whether rects intersect\n */\nconst intersects = (a, b) => {\n  const x = Math.max(a.x, b.x);\n  const num1 = Math.min(a.x + a.width, b.x + b.width);\n  const y = Math.max(a.y, b.y);\n  const num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\n\nconst getLineFragment = (lineRect, excludeRect) => {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  const eStart = excludeRect.x;\n  const eEnd = excludeRect.x + excludeRect.width;\n  const lStart = lineRect.x;\n  const lEnd = lineRect.x + lineRect.width;\n  const a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  const b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(r => r.width > 0);\n};\nconst getLineFragments = (rect, excludeRects) => {\n  let fragments = [rect];\n  for (let i = 0; i < excludeRects.length; i += 1) {\n    const excludeRect = excludeRects[i];\n    fragments = fragments.reduce((acc, fragment) => {\n      const pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  }\n  return fragments;\n};\nconst generateLineRects = (container, height) => {\n  const {\n    excludeRects,\n    ...rect\n  } = container;\n  if (!excludeRects) return [rect];\n  const lineRects = [];\n  const maxY = Math.max(...excludeRects.map(r => r.y + r.height));\n  let currentRect = rect;\n  while (currentRect.y < maxY) {\n    const [lineRect, rest] = partition(currentRect, height);\n    const lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push(...lineRectFragments);\n  }\n  return [...lineRects, currentRect];\n};\n\nconst ATTACHMENT_CODE$1 = '\\ufffc'; // 65532\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Remove attachment attribute if no char present\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string\n */\nconst purgeAttachments = attributedString => {\n  const shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return attributedString;\n  const runs = attributedString.runs.map(run => omit('attachment', run));\n  return Object.assign({}, attributedString, {\n    runs\n  });\n};\n\n/**\n * Layout paragraphs inside rectangle\n *\n * @param {Object} rects rect\n * @param {Object[]} lines attributed strings\n * @param {number} indent\n * @returns {Object} layout blocks\n */\nconst layoutLines = (rects, lines, indent) => {\n  let rect = rects.shift();\n  let currentY = rect.y;\n  return lines.map((line, i) => {\n    var _line$runs, _line$runs$;\n    const lineIndent = i === 0 ? indent : 0;\n    const style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    const height$1 = Math.max(height(line), style.lineHeight);\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n    const newLine = Object.assign({}, line);\n    delete newLine.syllables;\n    newLine.box = {\n      x: rect.x + lineIndent,\n      y: currentY,\n      width: rect.width - lineIndent,\n      height: height$1\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n\n/**\n * Performs line breaking and layout\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n */\nconst layoutParagraph = (engines, options) => {\n  /**\n   * @param {Rect} container rect\n   * @param {Object} paragraph attributed string\n   * @returns {Object} layout block\n   */\n  return (container, paragraph) => {\n    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;\n    const height$1 = height(paragraph);\n    const indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;\n    const rects = generateLineRects(container, height$1);\n    const availableWidths = rects.map(r => r.width);\n    availableWidths.unshift(availableWidths[0] - indent);\n    const lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n\n/**\n * Slice block at given height\n *\n * @param {number} height height\n * @param {Object} block paragraph block\n * @returns {number[]} sliced paragraph block\n */\nconst sliceAtHeight = (height, block) => {\n  const newBlock = [];\n  let counter = 0;\n  for (let i = 0; i < block.length; i += 1) {\n    const line = block[i];\n    counter += line.box.height;\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n  return newBlock;\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * Layout paragraphs inside container until it does not\n * fit anymore, performing line wrapping in the process.\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n * @param {Rect} container container rect\n */\nconst typesetter = (engines, options, container) => {\n  /**\n   * @param {AttributedString} attributedStrings attributed strings (paragraphs)\n   * @returns {Object[]} paragraph blocks\n   */\n  return attributedStrings => {\n    const blocks = [];\n    const paragraphs = [...attributedStrings];\n    const layoutBlock = layoutParagraph(engines, options);\n    const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    const truncateEllipsis = container.truncateMode === 'ellipsis';\n    let linesCount = maxLines;\n    let paragraphRect = copy(container);\n    let nextParagraph = paragraphs.shift();\n    while (linesCount > 0 && nextParagraph) {\n      const block = layoutBlock(paragraphRect, nextParagraph);\n      const slicedBlock = block.slice(0, linesCount);\n      const linesHeight = height$2(slicedBlock);\n      const shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n      if (paragraphRect.height >= linesHeight) {\n        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n    return blocks;\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string start value\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} start\n */\nconst start = attributedString => {\n  const {\n    runs\n  } = attributedString;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string end value\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} end\n */\nconst end = attributedString => {\n  const {\n    runs\n  } = attributedString;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string length\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} end\n */\nconst length$1 = attributedString => {\n  return end(attributedString) - start(attributedString);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Glyph} Glyph\n * @typedef {import('../types.js').Position} Position\n * @typedef {import('../types.js').Run} Run\n */\n\nconst bidi$2 = bidiFactory();\n\n/**\n * @param {Run[]} runs\n * @returns {number[]} bidi levels\n */\nconst getBidiLevels$1 = runs => {\n  return runs.reduce((acc, run) => {\n    const length = run.end - run.start;\n    const levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\nconst getReorderedIndices = (string, segments) => {\n  // Fill an array with indices\n  const indices = [];\n  for (let i = 0; i < string.length; i += 1) {\n    indices[i] = i;\n  }\n  // Reverse each segment in order\n  segments.forEach(_ref => {\n    let [start, end] = _ref;\n    const slice = indices.slice(start, end + 1);\n    for (let i = slice.length - 1; i >= 0; i -= 1) {\n      indices[end - i] = slice[i];\n    }\n  });\n  return indices;\n};\n\n/**\n * @template {'glyphs'|'positions'} T\n * @param {Run[]} runs\n * @param {T} objectName\n * @param {number} index\n * @returns {T extends 'glyphs' ? Glyph|undefined : Position|undefined}\n */\nconst getItemAtIndex = (runs, objectName, index) => {\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n    const updatedIndex = run.glyphIndices[index - run.start];\n    if (index >= run.start && index < run.end) {\n      return run[objectName][updatedIndex];\n    }\n  }\n  throw new Error(`index ${index} out of range`);\n};\n\n/**\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} reordered attributed string\n */\nconst reorderLine = attributedString => {\n  var _attributedString$run;\n  const levels = getBidiLevels$1(attributedString.runs);\n  const direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\n  const level = direction === 'rtl' ? 1 : 0;\n  const end = length$1(attributedString) - 1;\n  const paragraphs = [{\n    start: 0,\n    end,\n    level\n  }];\n  const embeddingLevels = {\n    paragraphs,\n    levels\n  };\n  const segments = bidi$2.getReorderSegments(attributedString.string, embeddingLevels);\n\n  // No need for bidi reordering\n  if (segments.length === 0) return attributedString;\n  const indices = getReorderedIndices(attributedString.string, segments);\n  const updatedString = bidi$2.getReorderedString(attributedString.string, embeddingLevels);\n  const updatedRuns = attributedString.runs.map(run => {\n    const selectedIndices = indices.slice(run.start, run.end);\n    const updatedGlyphs = [];\n    const updatedPositions = [];\n    const addedGlyphs = new Set();\n    for (let i = 0; i < selectedIndices.length; i += 1) {\n      const index = selectedIndices[i];\n      const glyph = getItemAtIndex(attributedString.runs, 'glyphs', index);\n      if (addedGlyphs.has(glyph.id)) continue;\n      updatedGlyphs.push(glyph);\n      updatedPositions.push(getItemAtIndex(attributedString.runs, 'positions', index));\n      if (glyph.isLigature) {\n        addedGlyphs.add(glyph.id);\n      }\n    }\n    return {\n      ...run,\n      glyphs: updatedGlyphs,\n      positions: updatedPositions\n    };\n  });\n  return {\n    ...attributedString,\n    runs: updatedRuns,\n    string: updatedString\n  };\n};\n\n/**\n * Reorder a paragraph\n *\n * @param {AttributedString[]} lines\n * @returns {AttributedString[]} reordered lines\n */\nconst reorderParagraph = lines => lines.map(reorderLine);\n\n/**\n * Perform bidi reordering\n *\n * @returns {(paragraphs: AttributedString[][]) => AttributedString[][]} reordered paragraphs\n */\nconst bidiReordering = () => {\n  /**\n   * @param {AttributedString[][]} paragraphs line blocks\n   * @returns {AttributedString[][]} reordered line blocks\n   */\n  return paragraphs => paragraphs.map(reorderParagraph);\n};\n\n/**\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\nconst DUMMY_CODEPOINT = 123;\n\n/**\n * Resolve string indices based on glyphs code points\n *\n * @param {Glyph[]} glyphs\n * @returns {number[]} glyph indices\n */\nconst resolve = function (glyphs) {\n  if (glyphs === void 0) {\n    glyphs = [];\n  }\n  return glyphs.reduce((acc, glyph) => {\n    const codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(() => 0);\n    const last = acc[acc.length - 1];\n    const next = codePoints.map(() => last + 1);\n    return [...acc, ...next];\n  }, []);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Position} Position\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * @param {Run} run\n * @returns {number}\n */\nconst getCharacterSpacing = run => {\n  var _run$attributes;\n  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;\n};\n\n/**\n * Scale run positions\n *\n * @param {Run} run\n * @param {Position[]} positions\n * @returns {Position[]} scaled positions\n */\nconst scalePositions = (run, positions) => {\n  const runScale = scale(run);\n  const characterSpacing = getCharacterSpacing(run);\n  return positions.map((position, i) => {\n    const isLast = i === positions.length;\n    const xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n\n/**\n * Create glyph run\n *\n * @param {string} string string\n */\nconst layoutRun = string => {\n  /**\n   * @param {Run} run run\n   * @returns {Run} glyph run\n   */\n  return run => {\n    const {\n      start,\n      end,\n      attributes = {}\n    } = run;\n    const {\n      font\n    } = attributes;\n    if (!font) return {\n      ...run,\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    };\n    const runString = string.slice(start, end);\n\n    // passing LTR To force fontkit to not reverse the string\n    const glyphRun = font.layout(runString, undefined, undefined, undefined, 'ltr');\n    const positions = scalePositions(run, glyphRun.positions);\n    const glyphIndices = resolve(glyphRun.glyphs);\n    return {\n      ...run,\n      positions,\n      glyphIndices,\n      glyphs: glyphRun.glyphs\n    };\n  };\n};\n\n/**\n * Generate glyphs for single attributed string\n */\nconst generateGlyphs = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string with glyphs\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(layoutRun(attributedString.string));\n    return Object.assign({}, attributedString, {\n      runs\n    });\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Resolves yOffset for run\n *\n * @param {Run} run run\n * @returns {Run} run\n */\nconst resolveRunYOffset = run => {\n  var _run$attributes, _run$attributes$font, _run$attributes2;\n  if (!run.positions) return run;\n  const unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;\n  const yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;\n  const positions = run.positions.map(p => Object.assign({}, p, {\n    yOffset\n  }));\n  return Object.assign({}, run, {\n    positions\n  });\n};\n\n/**\n * Resolves yOffset for multiple paragraphs\n */\nconst resolveYOffset = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(resolveRunYOffset);\n    return Object.assign({}, attributedString, {\n      runs\n    });\n  };\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Sort runs in ascending order\n *\n * @param {Run[]} runs\n * @returns {Run[]} sorted runs\n */\nconst sort = runs => {\n  return runs.sort((a, b) => a.start - b.start || a.end - b.end);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Is run empty (start === end)\n *\n * @param {Run} run run\n * @returns {boolean} is run empty\n */\nconst isEmpty = run => {\n  return run.start === run.end;\n};\n\n/**\n * @typedef {import('../types.js').Point} Point\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Sort points in ascending order\n * @param {Point} a first point\n * @param {Point} b second point\n * @returns {number} sort order\n */\nconst sortPoints = (a, b) => {\n  return a[1] - b[1] || a[3] - b[3];\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Point[]} points\n */\nconst generatePoints = runs => {\n  const result = runs.reduce((acc, run, i) => {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Run} merged runs\n */\nconst mergeRuns = runs => {\n  return runs.reduce((acc, run) => {\n    const attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes\n    });\n  }, {});\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Run[][]} grouped runs\n */\nconst groupEmptyRuns = runs => {\n  const groups = runs.reduce((acc, run) => {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, []);\n  return Object.values(groups);\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Run[]} flattened runs\n */\nconst flattenEmptyRuns = runs => {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n\n/**\n * @param {Run[]} runs\n * @returns {Run[]} flattened runs\n */\nconst flattenRegularRuns = runs => {\n  const res = [];\n  const points = generatePoints(runs);\n  let start = -1;\n  let attrs = {};\n  const stack = [];\n  for (let i = 0; i < points.length; i += 1) {\n    const [type, offset, attributes] = points[i];\n    if (start !== -1 && start < offset) {\n      res.push({\n        start,\n        end: offset,\n        attributes: attrs\n      });\n    }\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n      for (let j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          // eslint-disable-next-line no-plusplus\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n    start = offset;\n  }\n  return res;\n};\n\n/**\n * Flatten many runs\n *\n * @param {Run[]} runs\n * @returns {Run[]} flattened runs\n */\nconst flatten = function (runs) {\n  if (runs === void 0) {\n    runs = [];\n  }\n  const emptyRuns = flattenEmptyRuns(runs.filter(run => isEmpty(run)));\n  const regularRuns = flattenRegularRuns(runs.filter(run => !isEmpty(run)));\n  return sort(emptyRuns.concat(regularRuns));\n};\n\n/**\n * Returns empty attributed string\n *\n * @returns {Object} empty attributed string\n */\nconst empty = () => ({\n  string: '',\n  runs: []\n});\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n *\n * @param {AttributedString} attributedString\n * @returns {AttributedString} attributed string without font\n */\nconst omitFont = attributedString => {\n  const runs = attributedString.runs.map(run => omit('font', run));\n  return Object.assign({}, attributedString, {\n    runs\n  });\n};\n\n/**\n * Performs font substitution and script itemization on attributed string\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n */\nconst preprocessRuns = (engines, options) => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} processed attributed string\n   */\n  return attributedString => {\n    if (isNil(attributedString)) return empty();\n    const {\n      string\n    } = attributedString;\n    const {\n      fontSubstitution,\n      scriptItemizer,\n      bidi\n    } = engines;\n    const {\n      runs: omittedFontRuns\n    } = omitFont(attributedString);\n    const {\n      runs: itemizationRuns\n    } = scriptItemizer(options)(attributedString);\n    const {\n      runs: substitutedRuns\n    } = fontSubstitution(options)(attributedString);\n    const {\n      runs: bidiRuns\n    } = bidi(options)(attributedString);\n    const runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string,\n      runs: flatten(runs)\n    };\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Breaks attributed string into paragraphs\n */\nconst splitParagraphs = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString[]} attributed string array\n   */\n  return attributedString => {\n    const res = [];\n    let start = 0;\n    let breakPoint = attributedString.string.indexOf('\\n') + 1;\n    while (breakPoint > 0) {\n      res.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n    if (start === 0) {\n      res.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      res.push(slice(start, length$1(attributedString), attributedString));\n    }\n    return res;\n  };\n};\n\n/**\n * @typedef {import('../types.js').Position} Position\n */\n\n/**\n * Return positions advance width\n *\n * @param {Position[]} positions positions\n * @returns {number} advance width\n */\nconst advanceWidth$2 = positions => {\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Return run advance width\n *\n * @param {Run} run run\n * @returns {number} advance width\n */\nconst advanceWidth$1 = run => {\n  return advanceWidth$2(run.positions || []);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Returns attributed string advancewidth\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} advance width\n */\nconst advanceWidth = attributedString => {\n  const reducer = (acc, run) => acc + advanceWidth$1(run);\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/**\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\nconst WHITE_SPACES_CODE = 32;\n\n/**\n * Check if glyph is white space\n *\n * @param {Glyph} [glyph] glyph\n * @returns {boolean} whether glyph is white space\n * */\nconst isWhiteSpace = glyph => {\n  const codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n\n/**\n * @typedef {import('../types.js').Position} Position\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get white space leading positions\n *\n * @param {Run} run run\n * @returns {Position[]} white space leading positions\n */\nconst leadingPositions = run => {\n  const glyphs = run.glyphs || [];\n  const positions = run.positions || [];\n  const leadingWhitespaces = glyphs.findIndex(g => !isWhiteSpace(g));\n  return positions.slice(0, leadingWhitespaces);\n};\n\n/**\n * Get run leading white space offset\n *\n * @param {Run} run run\n * @returns {number} leading white space offset\n */\nconst leadingOffset$1 = run => {\n  const positions = leadingPositions(run);\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string leading white space offset\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} leading white space offset\n */\nconst leadingOffset = attributedString => {\n  const runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n\n/**\n * @typedef {import('../types.js').Position} Position\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * @template T\n * @param {T[]} array\n * @returns {T[]} reversed array\n */\nconst reverse = array => {\n  return [...array].reverse();\n};\n\n/**\n * Get white space trailing positions\n *\n * @param {Run} run run\n * @returns {Position[]} white space trailing positions\n */\nconst trailingPositions = run => {\n  const glyphs = reverse(run.glyphs || []);\n  const positions = reverse(run.positions || []);\n  const leadingWhitespaces = glyphs.findIndex(g => !isWhiteSpace(g));\n  return positions.slice(0, leadingWhitespaces);\n};\n\n/**\n * Get run trailing white space offset\n *\n * @param {Run} run run\n * @returns {number} trailing white space offset\n */\nconst trailingOffset$1 = run => {\n  const positions = trailingPositions(run);\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get attributed string trailing white space offset\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} trailing white space offset\n */\nconst trailingOffset = attributedString => {\n  const runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Drop last char of run\n *\n * @param {Run} run run\n * @returns {Run} run without last char\n */\nconst dropLast$1 = run => {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Drop last glyph\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string with new glyph\n */\nconst dropLast = attributedString => {\n  const string = dropLast$2(attributedString.string);\n  const runs = adjust(-1, dropLast$1, attributedString.runs);\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\n\nconst ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n\n/**\n * Remove new line char at the end of line if present\n *\n * @param {Object}  line\n * @returns {Object} line\n */\nconst removeNewLine = line => {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\nconst getOverflowLeft = line => {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\nconst getOverflowRight = line => {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param {Object}  line\n * @returns {Object} line\n */\nconst adjustOverflow = line => {\n  const overflowLeft = getOverflowLeft(line);\n  const overflowRight = getOverflowRight(line);\n  const x = line.box.x - overflowLeft;\n  const width = line.box.width + overflowLeft + overflowRight;\n  const box = Object.assign({}, line.box, {\n    x,\n    width\n  });\n  return Object.assign({}, line, {\n    box,\n    overflowLeft,\n    overflowRight\n  });\n};\n\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n * @param {string} align text align\n */\nconst justifyLine$1 = (engines, options, align) => {\n  /**\n   * @param {Object} line lint\n   * @returns {Object} line\n   */\n  return line => {\n    const lineWidth = advanceWidth(line);\n    const alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    const remainingWidth = Math.max(0, line.box.width - lineWidth);\n    const shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    const x = line.box.x + remainingWidth * alignFactor;\n    const box = Object.assign({}, line.box, {\n      x\n    });\n    const newLine = Object.assign({}, line, {\n      box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\nconst finalizeLine = line => {\n  let lineAscent = 0;\n  let lineDescent = 0;\n  let lineHeight = 0;\n  let lineXAdvance = 0;\n  const runs = line.runs.map(run => {\n    const height = height$1(run);\n    const ascent = ascent$1(run);\n    const descent$1 = descent(run);\n    const xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height,\n      ascent,\n      descent: descent$1,\n      xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n */\nconst finalizeBlock = function (engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n  /**\n   * @param {Object} line lint\n   * @param {number} i line index\n   * @param {Object[]} lines total lines\n   * @returns {Object} line\n   */\n  return (line, i, lines) => {\n    var _line$runs, _line$runs$;\n    const isLastFragment = i === lines.length - 1;\n    const style = ((_line$runs = line.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};\n    const align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(options), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param {Object} engines engines\n * @param {Object} options layout options\n */\nconst finalizeFragments = (engines, options) => {\n  /**\n   * @param {Object[]} blocks line blocks\n   * @returns {Object[]} blocks\n   */\n  return blocks => {\n    const blockFinalizer = finalizeBlock(engines, options);\n    return blocks.map(block => block.map(blockFinalizer));\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\nconst ATTACHMENT_CODE = 0xfffc; // 65532\n\nconst isReplaceGlyph = glyph => glyph.codePoints.includes(ATTACHMENT_CODE);\n\n/**\n * Resolve attachments of run\n *\n * @param {Object}  run\n * @returns {Object} run\n */\nconst resolveRunAttachments = run => {\n  var _run$attributes;\n  if (!run.positions) return run;\n  const glyphs = run.glyphs || [];\n  const attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};\n  const positions = run.positions.map((position, i) => {\n    const glyph = glyphs[i];\n    if (attachment && attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions\n  });\n};\n\n/**\n * Resolve attachments for multiple paragraphs\n */\nconst resolveAttachments = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(resolveRunAttachments);\n    return Object.assign({}, attributedString, {\n      runs\n    });\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Attributes} Attributes\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * @param {Attributes} a attributes\n * @returns {Attributes} attributes with defaults\n */\nconst applyAttributes = a => {\n  return {\n    align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    direction: a.direction || 'ltr',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || null,\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    verticalAlign: a.verticalAlign || null,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n\n/**\n * Apply default style to run\n *\n * @param {Run} run run\n * @returns {Run} run with styles\n */\nconst applyRunStyles = run => {\n  const attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes\n  });\n};\n\n/**\n * Apply default attributes for an attributed string\n */\nconst applyDefaultStyles = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const string = attributedString.string || '';\n    const runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string,\n      runs\n    };\n  };\n};\n\n/* eslint-disable no-restricted-syntax */\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\n */\nconst verticalAlignment = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    attributedString.runs.forEach(run => {\n      const {\n        attributes\n      } = run;\n      const {\n        verticalAlign\n      } = attributes;\n      if (verticalAlign === 'sub') {\n        attributes.yOffset = -0.2;\n      } else if (verticalAlign === 'super') {\n        attributes.yOffset = 0.4;\n      }\n    });\n    return attributedString;\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Run} Run\n */\n\nconst bidi$1 = bidiFactory();\n\n/**\n * @param {Run[]} runs\n * @returns {number[]} bidi levels\n */\nconst getBidiLevels = runs => {\n  return runs.reduce((acc, run) => {\n    const length = run.end - run.start;\n    const levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\n\n/**\n * Perform bidi mirroring\n */\nconst mirrorString = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const levels = getBidiLevels(attributedString.runs);\n    let updatedString = '';\n    attributedString.string.split('').forEach((char, index) => {\n      const isRTL = levels[index] % 2 === 1;\n      const mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index)) : null;\n      updatedString += mirroredChar || char;\n    });\n    return {\n      ...attributedString,\n      string: updatedString,\n      levels\n    };\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Rect} Rect\n */\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a Container object\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n *\n * @param {Object} engines engines\n */\nconst layoutEngine = engines => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @param {Rect} container container rect\n   * @param {Object} options layout options\n   * @returns {Object[]} paragraph blocks\n   */\n  return function (attributedString, container, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines, options));\n    const processParagraphs = paragraphs => paragraphs.map(processParagraph);\n    return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n  };\n};\n\nconst bidi = bidiFactory();\n\n/**\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @return {Object} attributed string\n */\nconst bidiEngine = () => attributedString => {\n  var _attributedString$run;\n  const {\n    string\n  } = attributedString;\n  const direction = (_attributedString$run = attributedString.runs[0]) === null || _attributedString$run === void 0 ? void 0 : _attributedString$run.attributes.direction;\n  const {\n    levels\n  } = bidi.getEmbeddingLevels(string, direction);\n  let lastLevel = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n  for (let i = 0; i < levels.length; i += 1) {\n    const level = levels[i];\n    if (level !== lastLevel) {\n      if (lastLevel !== null) {\n        res.push({\n          start: lastIndex,\n          end: index,\n          attributes: {\n            bidiLevel: lastLevel\n          }\n        });\n      }\n      lastIndex = index;\n      lastLevel = level;\n    }\n    index += 1;\n  }\n  if (lastIndex < string.length) {\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        bidiLevel: lastLevel\n      }\n    });\n  }\n  return {\n    string,\n    runs: res\n  };\n};\n\n/* eslint-disable no-plusplus */\nconst INFINITY = 10000;\n\n/**\n * @param {Object[]} subnodes\n * @param {number[]} widths\n * @param {number} lineNumber\n * @returns {number}\n */\nconst getNextBreakpoint = (subnodes, widths, lineNumber) => {\n  let position = null;\n  let minimumBadness = Infinity;\n  const sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  const lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n  const calculateRatio = node => {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n    return 0;\n  };\n  for (let i = 0; i < subnodes.length; i += 1) {\n    const node = subnodes[i];\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        let j = i === 0 ? i + 1 : i;\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n        position = j - 1;\n      }\n      break;\n    }\n    if (node.type === 'penalty' || node.type === 'glue') {\n      const ratio = calculateRatio(node);\n      const penalty = node.type === 'penalty' ? node.penalty : 0;\n      const badness = 100 * Math.abs(ratio) ** 3 + penalty;\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\n/**\n * @param {Object[]} nodes\n * @param {number[]} widths\n */\nconst applyBestFit = (nodes, widths) => {\n  let count = 0;\n  let lineNumber = 0;\n  let subnodes = nodes;\n  const breakpoints = [{\n    position: 0\n  }];\n  while (subnodes.length > 0) {\n    const breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n  return breakpoints;\n};\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\nclass Node {\n  constructor(data) {\n    this.prev = null;\n    this.next = null;\n    this.data = data;\n  }\n  toString() {\n    return this.data.toString();\n  }\n}\nclass LinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n    this.listLength = 0;\n  }\n  isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  }\n  size() {\n    return this.listSize;\n  }\n  isEmpty() {\n    return this.listSize === 0;\n  }\n  first() {\n    return this.head;\n  }\n  last() {\n    return this.last;\n  }\n  toString() {\n    return this.toArray().toString();\n  }\n  toArray() {\n    let node = this.head;\n    const result = [];\n    while (node !== null) {\n      result.push(node);\n      node = node.next;\n    }\n    return result;\n  }\n  forEach(fun) {\n    let node = this.head;\n    while (node !== null) {\n      fun(node);\n      node = node.next;\n    }\n  }\n  contains(n) {\n    let node = this.head;\n    if (!this.isLinked(n)) {\n      return false;\n    }\n    while (node !== null) {\n      if (node === n) {\n        return true;\n      }\n      node = node.next;\n    }\n    return false;\n  }\n  at(i) {\n    let node = this.head;\n    let index = 0;\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n      node = node.next;\n      index += 1;\n    }\n    return null;\n  }\n  insertAfter(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  }\n  insertBefore(node, newNode) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  }\n  push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n    return this;\n  }\n  unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n    return this;\n  }\n  remove(node) {\n    if (!this.isLinked(node)) {\n      return this;\n    }\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n    this.listSize -= 1;\n    return this;\n  }\n  pop() {\n    const node = this.tail;\n    this.tail.prev.next = null;\n    this.tail = this.tail.prev;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  }\n  shift() {\n    const node = this.head;\n    this.head.next.prev = null;\n    this.head = this.head.next;\n    this.listSize -= 1;\n    node.prev = null;\n    node.next = null;\n    return node;\n  }\n}\nLinkedList.Node = Node;\n\n/* eslint-disable no-restricted-properties */\n\n/**\n * @param {Object[]} nodes\n * @param {number[]} lines\n * @param {Object} settings\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\nconst linebreak = (nodes, lines, settings) => {\n  const options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  const activeNodes = new LinkedList();\n  const sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  const lineLengths = lines;\n  const breaks = [];\n  let tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position,\n      demerits,\n      ratio,\n      line,\n      fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous\n    };\n  }\n  function computeCost(start, end, active, currentLine) {\n    let width = sum.width - active.totals.width;\n    let stretch = 0;\n    let shrink = 0;\n    // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n    const lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n      return linebreak.infinity;\n    }\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n      return linebreak.infinity;\n    }\n\n    // perfect match\n    return 0;\n  }\n\n  // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n  function computeSum(breakPointIndex) {\n    const result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n    for (let i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n    return result;\n  }\n\n  // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n  function mainLoop(node, index, nodes) {\n    let active = activeNodes.first();\n    let next = null;\n    let ratio = 0;\n    let demerits = 0;\n    /**\n     * @type {Object[]}\n     */\n    let candidates = [];\n    let badness;\n    let currentLine = 0;\n    let tmpSum;\n    let currentClass = 0;\n    let fitnessClass;\n    /**\n     * @type {Object}\n     */\n    let candidate;\n    let newNode;\n\n    // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }];\n\n      // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine);\n\n        // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        }\n\n        // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3);\n\n          // Positive penalty\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);\n            // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);\n            // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          }\n\n          // Calculate the fitness class for this candidate active node.\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          }\n\n          // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          }\n\n          // Add the total demerits of the active node to get the total demerits of this candidate node.\n          demerits += active.data.demerits;\n\n          // Only store the best candidate for each fitness class\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active,\n              demerits,\n              ratio\n            };\n          }\n        }\n        active = next;\n\n        // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n      tmpSum = computeSum(index);\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n        if (candidate.demerits < Infinity) {\n          newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  }\n\n  // Add an active node for the start of the paragraph.\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, undefined, null)));\n\n  // eslint-disable-next-line no-shadow\n  nodes.forEach((node, index, nodes) => {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(node => {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n    return breaks.reverse();\n  }\n  return [];\n};\nlinebreak.infinity = 10000;\nlinebreak.glue = (width, value, stretch, shrink) => ({\n  type: 'glue',\n  value,\n  width,\n  stretch,\n  shrink\n});\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n  return {\n    type: 'box',\n    width,\n    value,\n    hyphenated\n  };\n};\nlinebreak.penalty = (width, penalty, flagged) => ({\n  type: 'penalty',\n  width,\n  penalty,\n  flagged\n});\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Add scalar to run\n *\n * @param {number} n scalar\n * @param {Run} run run\n * @returns {Run} added run\n */\nconst add = (n, run) => {\n  const start = run.start + n;\n  const end = run.end + n;\n  return Object.assign({}, run, {\n    start,\n    end\n  });\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Get run length\n *\n * @param {Run} run run\n * @returns {number} length\n */\nconst length = run => {\n  return run.end - run.start;\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Concats two runs into one\n *\n * @param {Run} runA first run\n * @param {Run} runB second run\n * @returns {Run} concatenated run\n */\nconst concat = (runA, runB) => {\n  const end = runA.end + length(runB);\n  const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  const positions = (runA.positions || []).concat(runB.positions || []);\n  const attributes = Object.assign({}, runA.attributes, runB.attributes);\n  const runAIndices = runA.glyphIndices || [];\n  const runALastIndex = last(runAIndices) || 0;\n  const runBIndices = (runB.glyphIndices || []).map(i => i + runALastIndex + 1);\n  const glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end,\n    glyphs,\n    positions,\n    attributes,\n    glyphIndices\n  });\n};\n\n/**\n * @typedef {import('../types.js').Glyph} Glyph\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Insert glyph to run in the given index\n *\n * @param {number} index index\n * @param {Glyph} glyph glyph\n * @param {Run} run run\n * @returns {Run} run with glyph\n */\nconst insertGlyph$1 = (index, glyph, run) => {\n  if (!glyph) return run;\n\n  // Split resolves ligature splitting in case new glyph breaks some\n  const leadingRun = slice$1(0, index, run);\n  const trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n\n/**\n * Insert either glyph or code point to run in the given index\n *\n * @param {number} index index\n * @param {Glyph | number} value glyph or codePoint\n * @param {Run} run run\n * @returns {Run} run with glyph\n */\nconst insert = (index, value, run) => {\n  const font = getFont(run);\n  const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Get run index at char index\n *\n * @param {number} n char index\n * @param {AttributedString} string attributed string\n * @returns {number} run index\n */\nconst runIndexAt = (n, string) => {\n  return runIndexAt$1(n, string.runs);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n * @typedef {import('../types.js').Glyph} Glyph\n */\n\n/**\n * Insert glyph into attributed string\n *\n * @param {number} index index\n * @param {Glyph} glyph glyph\n * @param {AttributedString} attributedString attributed string\n * @returns {AttributedString} attributed string with new glyph\n */\nconst insertGlyph = (index, glyph, attributedString) => {\n  const runIndex = runIndexAt(index, attributedString);\n\n  // Add glyph to the end if run index invalid\n  if (runIndex === -1) return append(glyph, attributedString);\n  const codePoints = (glyph.codePoints) || [];\n  const string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  const runs = attributedString.runs.map((run, i) => {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\n\n/**\n * @typedef {import('../types.js').Run} Run\n */\n\n/**\n * Advance width between two string indices\n *\n * @param {number} start glyph index\n * @param {number} end glyph index\n * @param {Run} run run\n * @returns {number} advanced width run\n */\nconst advanceWidthBetween$1 = (start, end, run) => {\n  const runStart = run.start || 0;\n  const glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  const glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Advance width between start and end\n * Does not consider ligature splitting for the moment.\n * Check performance impact on supporting this\n *\n * @param {number} start offset\n * @param {number} end offset\n * @param {AttributedString} attributedString\n * @returns {number} advance width\n */\nconst advanceWidthBetween = (start, end, attributedString) => {\n  const runs = filter(start, end, attributedString.runs);\n  return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start, end, run), 0);\n};\n\n/**\n * @typedef {import('../../types.js').AttributedString} AttributedString\n * @typedef {import('../../types.js').Attributes} Attributes\n */\n\nconst HYPHEN = 0x002d;\nconst TOLERANCE_STEPS = 5;\nconst TOLERANCE_LIMIT = 50;\nconst opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n\n/**\n * Slice attributed string to many lines\n *\n * @param {AttributedString} string attributed string\n * @param {Object[]} nodes\n * @param {Object[]} breaks\n * @returns {AttributedString[]} attributed strings\n */\nconst breakLines = (string, nodes, breaks) => {\n  let start = 0;\n  let end = null;\n  const lines = breaks.reduce((acc, breakPoint) => {\n    const node = nodes[breakPoint.position];\n    const prevNode = nodes[breakPoint.position - 1];\n\n    // Last breakpoint corresponds to K&P mandatory final glue\n    if (breakPoint.position === nodes.length - 1) return acc;\n    let line;\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = slice(start, end, string);\n      line = insertGlyph(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = slice(start, end, string);\n    }\n    start = end;\n    return [...acc, line];\n  }, []);\n\n  // Last line\n  lines.push(slice(start, string.string.length, string));\n  return lines;\n};\n\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {AttributedString} attributedString attributed string\n * @param {Object} args attributed string args\n * @param {Object} options layout options\n * @returns {Object[]} attributed strings\n */\nconst getNodes = (attributedString, _ref, options) => {\n  let {\n    align\n  } = _ref;\n  let start = 0;\n  const hyphenWidth = 5;\n  const {\n    syllables\n  } = attributedString;\n  const hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  const result = syllables.reduce((acc, s, index) => {\n    const width = advanceWidthBetween(start, start + s.length, attributedString);\n    if (s.trim() === '') {\n      const stretch = width * opts.width / opts.stretch;\n      const shrink = width * opts.width / opts.shrink;\n      const value = {\n        start,\n        end: start + s.length\n      };\n      acc.push(linebreak.glue(width, value, stretch, shrink));\n    } else {\n      const hyphenated = syllables[index + 1] !== ' ';\n      const value = {\n        start,\n        end: start + s.length\n      };\n      acc.push(linebreak.box(width, value, hyphenated));\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(linebreak.glue(0, null, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n\n/**\n * @param {AttributedString} attributedString attributed string\n * @returns {Attributes} styles\n */\nconst getStyles = attributedString => {\n  var _attributedString$run, _attributedString$run2;\n  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};\n};\n\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param {Object} options layout options\n */\nconst linebreaker = options => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @param {number[]} availableWidths available widths\n   * @returns {AttributedString[]} attributed strings\n   */\n  return (attributedString, availableWidths) => {\n    let tolerance = options.tolerance || 4;\n    const style = getStyles(attributedString);\n    const nodes = getNodes(attributedString, style, options);\n\n    /** @type {Object[]} */\n    let breaks = linebreak(nodes, availableWidths, {\n      tolerance\n    });\n\n    // Try again with a higher tolerance if the line breaking failed.\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, {\n        tolerance\n      });\n    }\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\n\nconst WHITESPACE_PRIORITY = 1;\nconst LETTER_PRIORITY = 2;\nconst EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nconst EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nconst SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nconst SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nconst getCharFactor = (direction, options) => {\n  const expandCharFactor = options.expandCharFactor || {};\n  const shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\nconst getWhitespaceFactor = (direction, options) => {\n  const expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  const shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === 'GROW' ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\nconst factor = (direction, options) => glyphs => {\n  const charFactor = getCharFactor(direction, options);\n  const whitespaceFactor = getWhitespaceFactor(direction, options);\n  const factors = [];\n  for (let index = 0; index < glyphs.length; index += 1) {\n    let f;\n    const glyph = glyphs[index];\n    if (isWhiteSpace(glyph)) {\n      f = Object.assign({}, whitespaceFactor);\n      if (index === glyphs.length - 1) {\n        f.before = 0;\n        if (index > 0) {\n          factors[index - 1].after = 0;\n        }\n      }\n    } else if (glyph.isMark && index > 0) {\n      f = Object.assign({}, factors[index - 1]);\n      f.before = 0;\n      factors[index - 1].after = 0;\n    } else {\n      f = Object.assign({}, charFactor);\n    }\n    factors.push(f);\n  }\n  return factors;\n};\nconst getFactors = (gap, line, options) => {\n  const direction = gap > 0 ? 'GROW' : 'SHRINK';\n  const getFactor = factor(direction, options);\n  const factors = line.runs.reduce((acc, run) => {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n\n/* eslint-disable no-multi-assign */\nconst KASHIDA_PRIORITY = 0;\nconst NULL_PRIORITY = 3;\nconst getDistances = (gap, factors) => {\n  let total = 0;\n  const priorities = [];\n  const unconstrained = [];\n  for (let priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    priorities[priority] = unconstrained[priority] = 0;\n  }\n\n  // sum the factors at each priority\n  for (let j = 0; j < factors.length; j += 1) {\n    const f = factors[j];\n    const sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  }\n\n  // choose the priorities that need to be applied\n  let highestPriority = -1;\n  let highestPrioritySum = 0;\n  let remainingGap = gap;\n  let priority;\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    const prioritySum = priorities[priority];\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      }\n\n      // if this priority covers the remaining gap, we're done\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      }\n\n      // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n      priorities[priority] = 1;\n      remainingGap -= prioritySum;\n\n      // if this priority has unconstrained glyphs, let them consume the remaining space\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  }\n\n  // zero out remaining priorities (if any)\n  for (let p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  }\n\n  // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  }\n\n  // create and return an array of distances to add to each glyph's advance\n  const distances = [];\n  for (let index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    const f = factors[index];\n    const next = factors[index + 1];\n    let dist = f.after * priorities[f.priority];\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    }\n\n    // if this glyph is unconstrained, add the unconstrained distance as well\n    if (f.unconstrained) {\n      dist += f.after * unconstrained[f.priority];\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n    distances.push(dist);\n  }\n  return distances;\n};\n\n/* eslint-disable consistent-return */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-restricted-syntax */\n\n\n/**\n * Adjust run positions by given distances\n *\n * @param {number[]} distances\n * @param {Object} line\n * @returns {Object} line\n */\nconst justifyLine = (distances, line) => {\n  let index = 0;\n  for (const run of line.runs) {\n    for (const position of run.positions) {\n      position.xAdvance += distances[index++];\n    }\n  }\n  return line;\n};\n\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n *\n * // TODO: Make it immutable\n *\n * @param {Object} options layout options\n */\nconst justification = options => {\n  /**\n   * @param {Object} line\n   * @returns {Object} line\n   */\n  return line => {\n    const gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return; // Exact fit\n\n    const factors = getFactors(gap, line, options);\n    const distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n\n/**\n * @typedef {import('../types.js').AttributedString} AttributedString\n */\n\n/**\n * Returns attributed string ascent\n *\n * @param {AttributedString} attributedString attributed string\n * @returns {number} ascent\n */\nconst ascent = attributedString => {\n  const reducer = (acc, run) => Math.max(acc, ascent$1(run));\n  return attributedString.runs.reduce(reducer, 0);\n};\n\n/* eslint-disable no-param-reassign */\n\n\n// The base font size used for calculating underline thickness.\nconst BASE_FONT_SIZE = 12;\n\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\nconst textDecoration = () => lineFragment => {\n  let x = lineFragment.overflowLeft || 0;\n  const overflowRight = lineFragment.overflowRight || 0;\n  const maxX = advanceWidth(lineFragment) - overflowRight;\n  lineFragment.decorationLines = [];\n  for (let i = 0; i < lineFragment.runs.length; i += 1) {\n    const run = lineFragment.runs[i];\n    const width = Math.min(maxX - x, advanceWidth$1(run));\n    const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n    if (run.attributes.underline) {\n      const rect = {\n        x,\n        y: ascent(lineFragment) + thickness * 2,\n        width,\n        height: thickness\n      };\n      const line = {\n        rect,\n        opacity: run.attributes.opacity,\n        color: run.attributes.underlineColor || 'black',\n        style: run.attributes.underlineStyle || 'solid'\n      };\n      lineFragment.decorationLines.push(line);\n    }\n    if (run.attributes.strike) {\n      const y = ascent(lineFragment) - ascent$1(run) / 3;\n      const rect = {\n        x,\n        y,\n        width,\n        height: thickness\n      };\n      const line = {\n        rect,\n        opacity: run.attributes.opacity,\n        color: run.attributes.strikeColor || 'black',\n        style: run.attributes.strikeStyle || 'solid'\n      };\n      lineFragment.decorationLines.push(line);\n    }\n    x += width;\n  }\n  return lineFragment;\n};\n\nconst ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n\n/**\n * @typedef {import('../../types.js').AttributedString} AttributedString\n */\n\n/**\n * Resolves unicode script in runs, grouping equal runs together\n */\nconst scriptItemizer = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const {\n      string\n    } = attributedString;\n    let lastScript = 'Unknown';\n    let lastIndex = 0;\n    let index = 0;\n    const res = [];\n    if (!string) return empty();\n    for (let i = 0; i < string.length; i += 1) {\n      const char = string[i];\n      const codePoint = char.codePointAt();\n      const script = unicode.getScript(codePoint);\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n        lastIndex = index;\n        lastScript = script;\n      }\n      index += char.length;\n    }\n    if (lastIndex < string.length) {\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n    return {\n      string,\n      runs: res\n    };\n  };\n};\n\nconst SOFT_HYPHEN = '\\u00ad';\nconst hyphenator = hyphen(pattern);\n\n/**\n * @param {string} word\n * @returns {string[]} word parts\n */\nconst splitHyphen = word => {\n  return word.split(SOFT_HYPHEN);\n};\nconst cache = {};\n\n/**\n * @param {string} word\n * @returns {string[]} word parts\n */\nconst getParts = word => {\n  const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\nconst wordHyphenation = () => {\n  /**\n   * @param {string} word word\n   * @returns {string[]} word parts\n   */\n  return word => {\n    const cacheKey = `_${word}`;\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\n/* eslint-disable no-restricted-syntax */\n\n\n/**\n * @typedef {import('../../types.js').AttributedString} AttributedString\n * @typedef {import('../../types.js').Run} Run\n */\n\n/**\n * @param {Run} run run\n * @returns {number}\n */\nconst getFontSize = run => {\n  return run.attributes.fontSize || 12;\n};\n\n/**\n * Resolve font runs in an AttributedString, grouping equal\n * runs and performing font substitution where necessary.\n */\nconst fontSubstitution = () => {\n  /**\n   * @param {AttributedString} attributedString attributed string\n   * @returns {AttributedString} attributed string\n   */\n  return attributedString => {\n    const {\n      string,\n      runs\n    } = attributedString;\n    let lastFont = null;\n    let lastIndex = 0;\n    let index = 0;\n    const res = [];\n    if (!string) return empty();\n    for (const run of runs) {\n      const fontSize = getFontSize(run);\n      const defaultFont = run.attributes.font;\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n      for (const char of string.slice(run.start, run.end)) {\n        const font = defaultFont;\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n          lastFont = font;\n          lastIndex = index;\n        }\n        index += char.length;\n      }\n    }\n    if (lastIndex < string.length) {\n      const fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n    return {\n      string,\n      runs: res\n    };\n  };\n};\n\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}