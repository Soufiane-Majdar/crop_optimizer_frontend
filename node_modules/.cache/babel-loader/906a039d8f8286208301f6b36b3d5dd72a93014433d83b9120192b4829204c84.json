{"ast":null,"code":"import _objectSpread from \"/home/sofiane/Desktop/Crop Nutrition Optimizer/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\nconst renderPath = (ctx, node) => {\n  var _node$props;\n  const d = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;\n  if (d) ctx.path(node.props.d);\n};\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5, _node$props6;\n  const x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;\n  const y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;\n  const rx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.rx) || 0;\n  const ry = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.ry) || 0;\n  const width = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.width) || 0;\n  const height = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.height) || 0;\n  if (!width || !height) return;\n  if (rx && ry) {\n    const krx = rx * KAPPA$3;\n    const kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n  ctx.closePath();\n};\nconst renderLine$1 = (ctx, node) => {\n  const {\n    x1,\n    x2,\n    y1,\n    y2\n  } = node.props || {};\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\nconst renderGroup = () => {\n  // noop\n};\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = function (ctx, cx, cy, rx, ry) {\n  if (cx === void 0) {\n    cx = 0;\n  }\n  if (cy === void 0) {\n    cy = 0;\n  }\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA$2;\n  const oy = ry * KAPPA$2;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n  const {\n    cx,\n    cy,\n    rx,\n    ry\n  } = node.props || {};\n  drawEllipse(ctx, cx, cy, rx, ry);\n};\nconst renderCircle = (ctx, node) => {\n  var _node$props, _node$props2, _node$props3;\n  const cx = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.cx;\n  const cy = (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.cy;\n  const r = (_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.r;\n  drawEllipse(ctx, cx, cy, r, r);\n};\nconst renderGlyphs = function (ctx, glyphs, positions, x, y, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const scale = 1000 / ctx._fontSize;\n  const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  const advanceWidthScale = 1000 / unitsPerEm;\n\n  // Glyph encoding and positioning\n  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n  const encodedPositions = positions.map((pos, i) => ({\n    xAdvance: pos.xAdvance * scale,\n    yAdvance: pos.yAdvance * scale,\n    xOffset: pos.xOffset,\n    yOffset: pos.yOffset,\n    advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n  }));\n  return ctx._glyphs(encodedGlyphs, encodedPositions, x, y, options);\n};\nconst renderRun$1 = (ctx, run) => {\n  const runAdvanceWidth = run.xAdvance;\n  const {\n    font,\n    fontSize,\n    color,\n    opacity\n  } = run.attributes;\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n  var _line$box, _line$box2, _line$runs$, _line$runs$2, _line$runs$2$attribut;\n  ctx.save();\n  const x = ((_line$box = line.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;\n  const y = ((_line$box2 = line.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;\n  const font = (_line$runs$ = line.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.font;\n  const scale = ((_line$runs$2 = line.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : (_line$runs$2$attribut = _line$runs$2.attributes) === null || _line$runs$2$attribut === void 0 ? void 0 : _line$runs$2$attribut.scale) || 1;\n  const width = line.xAdvance;\n  const ascent = font.ascent * scale;\n  const xHeight = font.xHeight * scale;\n  const descent = font.descent * scale;\n  const capHeight = font.capHeight * scale;\n  let xTranslate = x;\n  let yTranslate = y;\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n    case 'end':\n      xTranslate = x - width;\n      break;\n    default:\n      xTranslate = x;\n      break;\n  }\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n    default:\n      yTranslate = y;\n      break;\n  }\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(run => renderRun$1(ctx, run));\n  ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n  node.children.forEach(span => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\n/**\n * Create pairs from array\n *\n * @template T\n * @param {T[]} values array\n * @returns {T[][]} pairs\n */\nconst pairs = values => {\n  const result = [];\n  for (let i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n  return result;\n};\n\n/**\n * Parse svg-like points into number arrays\n *\n * @param {string} points string ex. \"20,30 50,60\"\n * @returns {number[][]} points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = points => {\n  let values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n  const mappedValues = values.map(parseFloat);\n  return pairs(mappedValues);\n};\nconst drawPolyline = (ctx, points) => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\nconst renderPolyline = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\nconst renderPolygon = (ctx, node) => {\n  renderPolyline(ctx, node);\n  ctx.closePath();\n};\nconst renderImage$1 = (ctx, node) => {\n  if (!node.image.data) return;\n  const {\n    x,\n    y\n  } = node.props;\n  const {\n    width,\n    height,\n    opacity\n  } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  if (width === 0 || height === 0) {\n    console.warn(\"Image with src '\".concat(node.props.href, \"' skipped due to invalid dimensions\"));\n    return;\n  }\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width,\n    height\n  });\n  ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n  if (!node.style) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style;\n\n  // Border top\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n\n  // Border right\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n\n  // Border bottom\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n\n  // Border left\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\nconst applySingleTransformation = (ctx, transform, origin) => {\n  const {\n    operation,\n    value\n  } = transform;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY] = value;\n        ctx.scale(scaleX, scaleY, {\n          origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        const [angle] = value;\n        ctx.rotate(angle, {\n          origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        const [x, y = 0] = value;\n        ctx.translate(x, y, {\n          origin\n        });\n        break;\n      }\n    case 'skew':\n      {\n        const [xAngle = 0, yAngle = 0] = value;\n        const radx = xAngle * Math.PI / 180;\n        const rady = yAngle * Math.PI / 180;\n        const tanx = Math.tan(radx);\n        const tany = Math.tan(rady);\n        let x = 0;\n        let y = 0;\n        if (origin != null) {\n          [x, y] = Array.from(origin);\n          const x1 = x + tanx * y;\n          const y1 = y + tany * x;\n          x -= x1;\n          y -= y1;\n        }\n        ctx.transform(1, tany, tanx, 1, x, y);\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform(...value);\n        break;\n      }\n    default:\n      {\n        console.error(\"Transform operation: '\".concat(operation, \"' doesn't supported\"));\n      }\n  }\n};\nconst applyTransformations = (ctx, node) => {\n  var _node$style, _node$props;\n  if (!node.origin) return;\n  const origin = [node.origin.left, node.origin.top];\n  const operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(operation => {\n    applySingleTransformation(ctx, operation, origin);\n  });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  var _node$props;\n  const path = normalizePath(absPath(parsePath(((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d) || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let i = 0, l = path.length; i < l; i += 1) {\n    const points = path[i].slice(1);\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n  return bounds;\n};\nconst getCircleBoundingBox = node => {\n  var _node$props2, _node$props3, _node$props4;\n  const r = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.r) || 0;\n  const cx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.cx) || 0;\n  const cy = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.cy) || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = node => {\n  var _node$props5, _node$props6, _node$props7, _node$props8;\n  const cx = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.cx) || 0;\n  const cy = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.cy) || 0;\n  const rx = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.rx) || 0;\n  const ry = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.ry) || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = node => {\n  var _node$props9, _node$props10, _node$props11, _node$props12;\n  const x1 = ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.x1) || 0;\n  const y1 = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.y1) || 0;\n  const x2 = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.x2) || 0;\n  const y2 = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.y2) || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\nconst getRectBoundingBox = node => {\n  var _node$props13, _node$props14, _node$props15, _node$props16;\n  const x = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.x) || 0;\n  const y = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.y) || 0;\n  const width = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.width) || 0;\n  const height = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.height) || 0;\n  return [x, y, x + width, y + height];\n};\nconst max = values => Math.max(-Infinity, ...values);\nconst min = values => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = node => {\n  var _node$props17;\n  const points = parsePoints(((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.points) || []);\n  const xValues = points.map(p => p[0]);\n  const yValues = points.map(p => p[1]);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n  [P.Rect]: getRectBoundingBox,\n  [P.Line]: getLineBoundingBox,\n  [P.Path]: getPathBoundingBox,\n  [P.Circle]: getCircleBoundingBox,\n  [P.Ellipse]: getEllipseBoundingBox,\n  [P.Polygon]: getPolylineBoundingBox,\n  [P.Polyline]: getPolylineBoundingBox\n};\nconst getBoundingBox = node => {\n  const boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\nconst setStrokeWidth = (ctx, node) => {\n  var _node$props;\n  const lineWidth = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n  var _node$props2;\n  const strokeColor = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n  var _node$props3;\n  const opacity = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n  var _node$props4;\n  const fillOpacity = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n  var _node$props5;\n  const strokeOpacity = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n  var _node$props6;\n  const lineJoin = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n  var _node$props7;\n  const lineCap = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;\n  if (lineCap) ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n  var _node$props8;\n  const value = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;\n  if (value) ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = node => {\n  var _node$props9, _node$props9$fill;\n  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === P.LinearGradient;\n};\nconst hasRadialGradientFill = node => {\n  var _node$props10, _node$props10$fill;\n  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === P.RadialGradient;\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n  var _node$props11;\n  const bbox = getBoundingBox(node);\n  const gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;\n  const x1 = gradient.props.x1 || 0;\n  const y1 = gradient.props.y1 || 0;\n  const x2 = gradient.props.x2 || 1;\n  const y2 = gradient.props.y2 || 0;\n  const m0 = bbox[2] - bbox[0];\n  const m3 = bbox[3] - bbox[1];\n  const m4 = bbox[0];\n  const m5 = bbox[1];\n  const gx1 = m0 * x1 + m4;\n  const gy1 = m3 * y1 + m5;\n  const gx2 = m0 * x2 + m4;\n  const gy2 = m3 * y2 + m5;\n  const grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n  gradient.children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n  var _node$props12;\n  const bbox = getBoundingBox(node);\n  const gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;\n  const cx = gradient.props.cx || 0.5;\n  const cy = gradient.props.cy || 0.5;\n  const fx = gradient.props.fx || cx;\n  const fy = gradient.props.fy || cy;\n  const r = gradient.props.r || 0.5;\n  const m0 = bbox[2] - bbox[0];\n  const m3 = bbox[3] - bbox[1];\n  const m4 = bbox[0];\n  const m5 = bbox[1];\n  const gr = r * m0;\n  const gcx = m0 * cx + m4;\n  const gcy = m3 * cy + m5;\n  const gfx = m0 * fx + m4;\n  const gfy = m3 * fy + m5;\n  const grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n  gradient.children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n  var _node$props13;\n  const fillColor = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;\n  if (fillColor) ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n  const props = node.props || {};\n  if (props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if (props.fill) {\n    ctx.fill(props.fillRule);\n  } else if (props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\nconst noop = () => {};\nconst renderFns$1 = {\n  [P.Tspan]: noop,\n  [P.TextInstance]: noop,\n  [P.Path]: renderPath,\n  [P.Rect]: renderRect,\n  [P.Line]: renderLine$1,\n  [P.G]: renderGroup,\n  [P.Text]: renderSvgText,\n  [P.Circle]: renderCircle,\n  [P.Image]: renderImage$1,\n  [P.Ellipse]: renderEllipse,\n  [P.Polygon]: renderPolygon,\n  [P.Polyline]: renderPolyline\n};\nconst renderNode$1 = (ctx, node) => {\n  const renderFn = renderFns$1[node.type];\n  if (renderFn) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(\"SVG node of type \".concat(node.type, \" is not currently supported\"));\n  }\n};\nconst drawNode = (ctx, node) => {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n  var _node$props14;\n  const value = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;\n  if (value) {\n    const children = value.children || [];\n    children.forEach(child => renderNode$1(ctx, child));\n    ctx.clip();\n  }\n};\nconst drawChildren = (ctx, node) => {\n  const children = node.children || [];\n  children.forEach(child => {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\nconst resolveAspectRatio = (ctx, node) => {\n  const {\n    width,\n    height\n  } = node.box;\n  const {\n    viewBox,\n    preserveAspectRatio = {}\n  } = node.props;\n  const {\n    meetOrSlice = 'meet',\n    align = 'xMidYMid'\n  } = preserveAspectRatio;\n  if (viewBox == null || width == null || height == null) return;\n  const x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;\n  const y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;\n  const logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;\n  const logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height;\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\nconst moveToOrigin = (ctx, node) => {\n  const {\n    top,\n    left\n  } = node.box;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\nconst black = {\n  value: [0, 0, 0],\n  opacity: 1\n};\nconst parseColor = hex => {\n  const parsed = colorString.get(hex);\n  if (!parsed) return black;\n  const value = colorString.to.hex(parsed.value.slice(0, 3));\n  const opacity = parsed.value[3];\n  return {\n    value,\n    opacity\n  };\n};\n\n/* eslint-disable no-param-reassign */\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = src => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    width,\n    height,\n    image\n  } = attachment;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\nconst renderAttachments = (ctx, run) => {\n  ctx.save();\n  const {\n    font\n  } = run.attributes;\n  const space = font.glyphForCodePoint(0x20);\n  const objectReplacement = font.glyphForCodePoint(0xfffc);\n  let attachmentAdvance = 0;\n  for (let i = 0; i < run.glyphs.length; i += 1) {\n    const position = run.positions[i];\n    const glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n  ctx.restore();\n};\nconst renderRun = (ctx, run, options) => {\n  const {\n    font,\n    fontSize,\n    link\n  } = run.attributes;\n  const color = parseColor(run.attributes.color);\n  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  const {\n    height,\n    descent,\n    xAdvance\n  } = run;\n  if (options.outlineRuns) {\n    ctx.rect(0, -height, xAdvance, height).stroke();\n  }\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n  renderAttachments(ctx, run);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n  const color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\nconst renderDecorationLine = (ctx, line) => {\n  ctx.save();\n  ctx.lineWidth(line.rect.height);\n  ctx.strokeOpacity(line.opacity);\n  if (/dashed/.test(line.style)) {\n    ctx.dash(3 * line.rect.height);\n  } else if (/dotted/.test(line.style)) {\n    ctx.dash(line.rect.height);\n  }\n  if (/wavy/.test(line.style)) {\n    const dist = Math.max(2, line.rect.height);\n    let step = 1.1 * dist;\n    const stepCount = Math.floor(line.rect.width / (2 * step));\n\n    // Adjust step to fill entire width\n    const remainingWidth = line.rect.width - stepCount * 2 * step;\n    const adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    const cp1y = line.rect.y + dist;\n    const cp2y = line.rect.y - dist;\n    let {\n      x\n    } = line.rect;\n    ctx.moveTo(line.rect.x, line.rect.y);\n    for (let i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(line.rect.x, line.rect.y);\n    ctx.lineTo(line.rect.x + line.rect.width, line.rect.y);\n    if (/double/.test(line.style)) {\n      ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);\n      ctx.lineTo(line.rect.x + line.rect.width, line.rect.y + line.rect.height * 2);\n    }\n  }\n  ctx.stroke(line.color);\n  ctx.restore();\n};\nconst renderLine = (ctx, line, options) => {\n  const lineAscent = line.ascent;\n  if (options.outlineLines) {\n    ctx.rect(line.box.x, line.box.y, line.box.width, line.box.height).stroke();\n  }\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const isLastRun = i === line.runs.length - 1;\n    if (run.attributes.backgroundColor) {\n      const overflowRight = isLastRun ? line.overflowRight : 0;\n      const backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: run.xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n    renderRun(ctx, run, options);\n  }\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n  for (let i = 0; i < line.decorationLines.length; i += 1) {\n    const decorationLine = line.decorationLines[i];\n    renderDecorationLine(ctx, decorationLine);\n  }\n  ctx.restore();\n};\nconst renderBlock = (ctx, block, options) => {\n  block.forEach(line => {\n    renderLine(ctx, line, options);\n  });\n};\nconst renderText = (ctx, node) => {\n  var _node$box, _node$box2;\n  const {\n    top,\n    left\n  } = node.box;\n  const blocks = [node.lines];\n  const paddingTop = ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.paddingTop) || 0;\n  const paddingLeft = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingLeft) || 0;\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  const offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(block => {\n    renderBlock(ctx, block, {});\n  });\n  ctx.restore();\n};\nconst renderPage = (ctx, node) => {\n  var _node$props;\n  const {\n    width,\n    height\n  } = node.box;\n  const dpi = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.dpi) || 72;\n  const userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit\n  });\n};\nconst renderNote = (ctx, node) => {\n  var _node$children, _node$style, _node$style2;\n  const {\n    top,\n    left\n  } = node.box;\n  const value = (node === null || node === void 0 ? void 0 : (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || '';\n  const color = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor) || null;\n  const borderWidth = ((_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.borderWidth) || null;\n  ctx.note(left, top, 0, 0, value, {\n    color,\n    borderWidth\n  });\n};\nconst isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width,\n      height,\n      xOffset,\n      yOffset\n    };\n  }\n  const width = cw;\n  const height = width / ir;\n  const xOffset = isNumeric(px) ? px : 0;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    yOffset,\n    xOffset\n  };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width,\n      height,\n      yOffset,\n      xOffset\n    };\n  }\n  const height = ch;\n  const width = height * ir;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : 0;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0\n  };\n};\nconst resolveObjectFit = function (type, cw, ch, iw, ih, px, py) {\n  if (type === void 0) {\n    type = 'fill';\n  }\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\nconst drawImage = function (ctx, node, options) {\n  var _node$style, _node$style2, _node$style3, _node$style4;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    left,\n    top\n  } = node.box;\n  const opacity = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity;\n  const objectFit = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.objectFit;\n  const objectPositionX = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectPositionX;\n  const objectPositionY = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionY;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const imageCache = options.imageCache || new Map();\n  const {\n    width,\n    height,\n    xOffset,\n    yOffset\n  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      const cacheKey = node.image.key;\n      const image = imageCache.get(cacheKey) || ctx.embedImage(node.image.data);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      const imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width,\n        height\n      });\n    } else {\n      console.warn(\"Image with src '\".concat(JSON.stringify(node.props.src), \"' skipped due to invalid dimensions\"));\n    }\n  }\n};\nconst renderImage = (ctx, node, options) => {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n\n// TODO: Draw debug boxes using clipping to enhance quality\n\nconst debugContent = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\nconst debugPadding = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n\n  // Padding top\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();\n\n  // Padding left\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding right\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding bottom\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\nconst getMargin = box => {\n  const marginLeft = box.marginLeft === 'auto' ? 0 : box.marginLeft;\n  const marginTop = box.marginTop === 'auto' ? 0 : box.marginTop;\n  const marginRight = box.marginRight === 'auto' ? 0 : box.marginRight;\n  const marginBottom = box.marginBottom === 'auto' ? 0 : box.marginBottom;\n  return {\n    marginLeft,\n    marginTop,\n    marginRight,\n    marginBottom\n  };\n};\nconst debugMargin = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = getMargin(node.box);\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n\n  // Margin left\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill();\n\n  // Margin right\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill();\n\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = getMargin(node.box);\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(\"\".concat(roundedWidth, \" x \").concat(roundedHeight), left - marginLeft, Math.max(top - marginTop - 4, 1));\n};\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\nconst renderDebug = (ctx, node) => {\n  var _node$props;\n  if (!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.debug)) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\nconst availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\nconst painter = ctx => {\n  const p = availableMethods.reduce((acc, prop) => _objectSpread(_objectSpread({}, acc), {}, {\n    [prop]: function () {\n      ctx[prop](...arguments);\n      return p;\n    }\n  }), {});\n  return p;\n};\nconst renderCanvas = (ctx, node) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n  ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n\n  // Clip inner right border edge\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top);\n\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n\n  // Clip inner bottom border edge\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style;\n\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n\n  // Clip inner left border edge\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height);\n\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return;\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = node.box;\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n  ctx.restore();\n};\nconst drawBackground = (ctx, node) => {\n  var _node$style;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const color = parseColor(node.style.backgroundColor);\n  const nodeOpacity = isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity) ? 1 : node.style.opacity;\n  const opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\nconst renderBackground = (ctx, node) => {\n  var _node$style2;\n  const hasBackground = !!node.box && !!((_node$style2 = node.style) !== null && _node$style2 !== void 0 && _node$style2.backgroundColor);\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\nconst isSrcId = value => /^#.+/.test(value);\nconst setLink = (ctx, node) => {\n  const props = node.props || {};\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const src = props.src || props.href;\n  if (src) {\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    ctx[method](left, top, width, height, value);\n  }\n};\nconst setDestination = (ctx, node) => {\n  var _node$props;\n  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.id) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\nconst isRecursiveNode = node => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n  ctx.save();\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n  const children = node.children || [];\n  const renderChild = child => renderNode(ctx, child, options);\n  children.forEach(renderChild);\n  ctx.restore();\n};\nconst renderFns = {\n  [P.Text]: renderText,\n  [P.Note]: renderNote,\n  [P.Image]: renderImage,\n  [P.Canvas]: renderCanvas,\n  [P.Svg]: renderSvg,\n  [P.Link]: setLink\n};\nconst renderNode = (ctx, node, options) => {\n  var _node$style;\n  const overflowHidden = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.overflow) === 'hidden';\n  const shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  const renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\n\n/* eslint-disable no-param-reassign */\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n  var _node$props;\n  const bookmark = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.bookmark;\n  if (bookmark) {\n    const {\n      title,\n      parent,\n      expanded,\n      zoom,\n      fit\n    } = bookmark;\n    const outline = registry[parent] || ctx.outline;\n    const top = bookmark.top || node.box.top;\n    const left = bookmark.left || node.box.left;\n    const instance = outline.addItem(title, {\n      pageNumber,\n      expanded,\n      top,\n      left,\n      zoom,\n      fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n  if (!node.children) return;\n  node.children.forEach(child => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n  const registry = {};\n  const pages = root.children || [];\n  pages.forEach((page, i) => {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\nconst render = (ctx, doc) => {\n  const pages = doc.children || [];\n  const options = {\n    imageCache: new Map()\n  };\n  pages.forEach(page => renderNode(ctx, page, options));\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\nexport { render as default };","map":{"version":3,"names":["P","isNil","matchPercent","absPath","parsePath","normalizePath","colorString","renderPath","ctx","node","_node$props","d","props","path","KAPPA$3","Math","sqrt","renderRect","_node$props2","_node$props3","_node$props4","_node$props5","_node$props6","x","y","rx","ry","width","height","krx","kry","moveTo","lineTo","bezierCurveTo","closePath","renderLine$1","x1","x2","y1","y2","renderGroup","KAPPA$2","drawEllipse","cx","cy","ox","oy","xe","ye","xm","ym","renderEllipse","renderCircle","r","renderGlyphs","glyphs","positions","options","scale","_fontSize","unitsPerEm","_font","font","advanceWidthScale","encodedGlyphs","encodeGlyphs","encodedPositions","map","pos","i","xAdvance","yAdvance","xOffset","yOffset","advanceWidth","_glyphs","renderRun$1","run","runAdvanceWidth","fontSize","color","opacity","attributes","fillColor","fillOpacity","sbix","COLR","CPAL","save","translate","ascent","length","position","glyph","render","restore","name","error","console","log","renderSpan","line","textAnchor","dominantBaseline","_line$box","_line$box2","_line$runs$","_line$runs$2","_line$runs$2$attribut","box","runs","xHeight","descent","capHeight","xTranslate","yTranslate","forEach","renderSvgText","children","span","lines","pairs","values","result","push","parsePoints","points","trim","replace","split","slice","mappedValues","parseFloat","drawPolyline","p","renderPolyline","renderPolygon","renderImage$1","image","data","style","paddingTop","paddingLeft","warn","concat","href","KAPPA$1","clipNode","top","left","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","min","ctr","rbr","cbr","rbl","cbl","rtl","ctl","clip","applySingleTransformation","transform","origin","operation","value","scaleX","scaleY","angle","rotate","xAngle","yAngle","radx","PI","rady","tanx","tan","tany","Array","from","applyTransformations","_node$style","operations","getPathBoundingBox","bounds","Infinity","l","j","getCircleBoundingBox","getEllipseBoundingBox","_node$props7","_node$props8","getLineBoundingBox","_node$props9","_node$props10","_node$props11","_node$props12","max","getRectBoundingBox","_node$props13","_node$props14","_node$props15","_node$props16","getPolylineBoundingBox","_node$props17","xValues","yValues","boundingBoxFns","Rect","Line","Path","Circle","Ellipse","Polygon","Polyline","getBoundingBox","boundingBoxFn","type","setStrokeWidth","lineWidth","strokeWidth","setStrokeColor","strokeColor","stroke","setOpacity","setFillOpacity","setStrokeOpacity","strokeOpacity","setLineJoin","lineJoin","strokeLinejoin","setLineCap","lineCap","strokeLinecap","setLineDash","strokeDasharray","dash","Number","hasLinearGradientFill","_node$props9$fill","fill","LinearGradient","hasRadialGradientFill","_node$props10$fill","RadialGradient","setLinearGradientFill","bbox","gradient","m0","m3","m4","m5","gx1","gy1","gx2","gy2","grad","linearGradient","stop","offset","stopColor","stopOpacity","setRadialGradientFill","fx","fy","gr","gcx","gcy","gfx","gfy","radialGradient","setFillColor","setFill","draw","fillAndStroke","fillRule","noop","renderFns$1","Tspan","TextInstance","G","Text","Image","renderNode$1","renderFn","drawNode","clipPath","child","drawChildren","resolveAspectRatio","viewBox","preserveAspectRatio","meetOrSlice","align","minX","minY","logicalWidth","maxX","logicalHeight","maxY","logicalRatio","physicalRatio","moveToOrigin","renderSvg","black","parseColor","hex","parsed","get","to","DEST_REGEXP","isSrcId$1","src","match","renderAttachment","attachment","fit","valign","renderAttachments","space","glyphForCodePoint","objectReplacement","attachmentAdvance","id","renderRun","link","outlineRuns","rect","goTo","renderBackground$1","backgroundColor","renderDecorationLine","test","dist","step","stepCount","floor","remainingWidth","adjustment","cp1y","cp2y","renderLine","lineAscent","outlineLines","isLastRun","overflowRight","backgroundRect","decorationLines","decorationLine","renderBlock","block","renderText","_node$box","_node$box2","blocks","initialY","offsetX","alignOffset","renderPage","dpi","userUnit","addPage","size","margin","renderNote","_node$children","_node$style2","borderWidth","note","isNumeric","n","isNaN","isFinite","applyContainObjectFit","cw","ch","iw","ih","px","py","cr","ir","pxp","pyp","pxv","percent","pyv","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","drawImage","_node$style3","_node$style4","objectFit","objectPositionX","objectPositionY","paddingRight","paddingBottom","imageCache","Map","cacheKey","key","embedImage","set","imageOpacity","JSON","stringify","renderImage","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","debugContent","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","debugPadding","getMargin","marginLeft","marginTop","marginRight","marginBottom","debugMargin","debugText","roundedWidth","round","roundedHeight","text","debugOrigin","circle","renderDebug","debug","availableMethods","painter","reduce","acc","prop","_objectSpread","arguments","renderCanvas","availableWidth","availableHeight","paint","KAPPA","clipBorderTop","layout","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","borderTopColor","borderTopStyle","undash","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","renderBorders","drawBackground","nodeOpacity","renderBackground","hasBackground","isSrcId","setLink","isId","method","setDestination","addNamedDestination","isRecursiveNode","Svg","renderChildren","renderChild","renderNode","renderFns","Note","Canvas","Link","overflowHidden","overflow","shouldRenderChildren","Page","addNodeBookmark","pageNumber","registry","bookmark","title","parent","expanded","zoom","outline","instance","addItem","ref","addBookmarks","root","pages","page","doc","end","default"],"sources":["/home/sofiane/Desktop/Crop Nutrition Optimizer/frontend/node_modules/@react-pdf/render/lib/index.js"],"sourcesContent":["import * as P from '@react-pdf/primitives';\nimport { isNil, matchPercent } from '@react-pdf/fns';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport normalizePath from 'normalize-svg-path';\nimport colorString from 'color-string';\n\nconst renderPath = (ctx, node) => {\n  var _node$props;\n  const d = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;\n  if (d) ctx.path(node.props.d);\n};\n\nconst KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst renderRect = (ctx, node) => {\n  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5, _node$props6;\n  const x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;\n  const y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;\n  const rx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.rx) || 0;\n  const ry = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.ry) || 0;\n  const width = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.width) || 0;\n  const height = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.height) || 0;\n  if (!width || !height) return;\n  if (rx && ry) {\n    const krx = rx * KAPPA$3;\n    const kry = ry * KAPPA$3;\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n  ctx.closePath();\n};\n\nconst renderLine$1 = (ctx, node) => {\n  const {\n    x1,\n    x2,\n    y1,\n    y2\n  } = node.props || {};\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n};\n\nconst renderGroup = () => {\n  // noop\n};\n\nconst KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst drawEllipse = function (ctx, cx, cy, rx, ry) {\n  if (cx === void 0) {\n    cx = 0;\n  }\n  if (cy === void 0) {\n    cy = 0;\n  }\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA$2;\n  const oy = ry * KAPPA$2;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\nconst renderEllipse = (ctx, node) => {\n  const {\n    cx,\n    cy,\n    rx,\n    ry\n  } = node.props || {};\n  drawEllipse(ctx, cx, cy, rx, ry);\n};\n\nconst renderCircle = (ctx, node) => {\n  var _node$props, _node$props2, _node$props3;\n  const cx = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.cx;\n  const cy = (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.cy;\n  const r = (_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.r;\n  drawEllipse(ctx, cx, cy, r, r);\n};\n\nconst renderGlyphs = function (ctx, glyphs, positions, x, y, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const scale = 1000 / ctx._fontSize;\n  const unitsPerEm = ctx._font.font.unitsPerEm || 1000;\n  const advanceWidthScale = 1000 / unitsPerEm;\n\n  // Glyph encoding and positioning\n  const encodedGlyphs = ctx._font.encodeGlyphs(glyphs);\n  const encodedPositions = positions.map((pos, i) => ({\n    xAdvance: pos.xAdvance * scale,\n    yAdvance: pos.yAdvance * scale,\n    xOffset: pos.xOffset,\n    yOffset: pos.yOffset,\n    advanceWidth: glyphs[i].advanceWidth * advanceWidthScale\n  }));\n  return ctx._glyphs(encodedGlyphs, encodedPositions, x, y, options);\n};\n\nconst renderRun$1 = (ctx, run) => {\n  const runAdvanceWidth = run.xAdvance;\n  const {\n    font,\n    fontSize,\n    color,\n    opacity\n  } = run.attributes;\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(runAdvanceWidth, 0);\n};\nconst renderSpan = (ctx, line, textAnchor, dominantBaseline) => {\n  var _line$box, _line$box2, _line$runs$, _line$runs$2, _line$runs$2$attribut;\n  ctx.save();\n  const x = ((_line$box = line.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;\n  const y = ((_line$box2 = line.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;\n  const font = (_line$runs$ = line.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.font;\n  const scale = ((_line$runs$2 = line.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : (_line$runs$2$attribut = _line$runs$2.attributes) === null || _line$runs$2$attribut === void 0 ? void 0 : _line$runs$2$attribut.scale) || 1;\n  const width = line.xAdvance;\n  const ascent = font.ascent * scale;\n  const xHeight = font.xHeight * scale;\n  const descent = font.descent * scale;\n  const capHeight = font.capHeight * scale;\n  let xTranslate = x;\n  let yTranslate = y;\n  switch (textAnchor) {\n    case 'middle':\n      xTranslate = x - width / 2;\n      break;\n    case 'end':\n      xTranslate = x - width;\n      break;\n    default:\n      xTranslate = x;\n      break;\n  }\n  switch (dominantBaseline) {\n    case 'middle':\n    case 'central':\n      yTranslate = y + capHeight / 2;\n      break;\n    case 'hanging':\n      yTranslate = y + capHeight;\n      break;\n    case 'mathematical':\n      yTranslate = y + xHeight;\n      break;\n    case 'text-after-edge':\n      yTranslate = y + descent;\n      break;\n    case 'text-before-edge':\n      yTranslate = y + ascent;\n      break;\n    default:\n      yTranslate = y;\n      break;\n  }\n  ctx.translate(xTranslate, yTranslate);\n  line.runs.forEach(run => renderRun$1(ctx, run));\n  ctx.restore();\n};\nconst renderSvgText = (ctx, node) => {\n  node.children.forEach(span => renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline));\n};\n\n/**\n * Create pairs from array\n *\n * @template T\n * @param {T[]} values array\n * @returns {T[][]} pairs\n */\nconst pairs = values => {\n  const result = [];\n  for (let i = 0; i < values.length; i += 2) {\n    result.push([values[i], values[i + 1]]);\n  }\n  return result;\n};\n\n/**\n * Parse svg-like points into number arrays\n *\n * @param {string} points string ex. \"20,30 50,60\"\n * @returns {number[][]} points array ex. [[20, 30], [50, 60]]\n */\nconst parsePoints = points => {\n  let values = (points || '').trim().replace(/,/g, ' ').replace(/(\\d)-(\\d)/g, '$1 -$2').split(/\\s+/);\n  if (values.length % 2 !== 0) {\n    values = values.slice(0, -1);\n  }\n  const mappedValues = values.map(parseFloat);\n  return pairs(mappedValues);\n};\n\nconst drawPolyline = (ctx, points) => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\nconst renderPolyline = (ctx, node) => {\n  const points = parsePoints(node.props.points || '');\n  drawPolyline(ctx, points);\n};\n\nconst renderPolygon = (ctx, node) => {\n  renderPolyline(ctx, node);\n  ctx.closePath();\n};\n\nconst renderImage$1 = (ctx, node) => {\n  if (!node.image.data) return;\n  const {\n    x,\n    y\n  } = node.props;\n  const {\n    width,\n    height,\n    opacity\n  } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  if (width === 0 || height === 0) {\n    console.warn(`Image with src '${node.props.href}' skipped due to invalid dimensions`);\n    return;\n  }\n  ctx.save();\n  ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n    width,\n    height\n  });\n  ctx.restore();\n};\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipNode = (ctx, node) => {\n  if (!node.style) return;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0\n  } = node.style;\n\n  // Border top\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA$1);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);\n\n  // Border right\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA$1);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height);\n\n  // Border bottom\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA$1);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl);\n\n  // Border left\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA$1);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n  const {\n    operation,\n    value\n  } = transform;\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY] = value;\n        ctx.scale(scaleX, scaleY, {\n          origin\n        });\n        break;\n      }\n    case 'rotate':\n      {\n        const [angle] = value;\n        ctx.rotate(angle, {\n          origin\n        });\n        break;\n      }\n    case 'translate':\n      {\n        const [x, y = 0] = value;\n        ctx.translate(x, y, {\n          origin\n        });\n        break;\n      }\n    case 'skew':\n      {\n        const [xAngle = 0, yAngle = 0] = value;\n        const radx = xAngle * Math.PI / 180;\n        const rady = yAngle * Math.PI / 180;\n        const tanx = Math.tan(radx);\n        const tany = Math.tan(rady);\n        let x = 0;\n        let y = 0;\n        if (origin != null) {\n          [x, y] = Array.from(origin);\n          const x1 = x + tanx * y;\n          const y1 = y + tany * x;\n          x -= x1;\n          y -= y1;\n        }\n        ctx.transform(1, tany, tanx, 1, x, y);\n        break;\n      }\n    case 'matrix':\n      {\n        ctx.transform(...value);\n        break;\n      }\n    default:\n      {\n        console.error(`Transform operation: '${operation}' doesn't supported`);\n      }\n  }\n};\nconst applyTransformations = (ctx, node) => {\n  var _node$style, _node$props;\n  if (!node.origin) return;\n  const origin = [node.origin.left, node.origin.top];\n  const operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(operation => {\n    applySingleTransformation(ctx, operation, origin);\n  });\n};\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  var _node$props;\n  const path = normalizePath(absPath(parsePath(((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d) || '')));\n  if (!path.length) return [0, 0, 0, 0];\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n  for (let i = 0, l = path.length; i < l; i += 1) {\n    const points = path[i].slice(1);\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n  return bounds;\n};\nconst getCircleBoundingBox = node => {\n  var _node$props2, _node$props3, _node$props4;\n  const r = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.r) || 0;\n  const cx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.cx) || 0;\n  const cy = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.cy) || 0;\n  return [cx - r, cy - r, cx + r, cy + r];\n};\nconst getEllipseBoundingBox = node => {\n  var _node$props5, _node$props6, _node$props7, _node$props8;\n  const cx = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.cx) || 0;\n  const cy = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.cy) || 0;\n  const rx = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.rx) || 0;\n  const ry = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.ry) || 0;\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\nconst getLineBoundingBox = node => {\n  var _node$props9, _node$props10, _node$props11, _node$props12;\n  const x1 = ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.x1) || 0;\n  const y1 = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.y1) || 0;\n  const x2 = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.x2) || 0;\n  const y2 = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.y2) || 0;\n  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];\n};\nconst getRectBoundingBox = node => {\n  var _node$props13, _node$props14, _node$props15, _node$props16;\n  const x = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.x) || 0;\n  const y = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.y) || 0;\n  const width = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.width) || 0;\n  const height = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.height) || 0;\n  return [x, y, x + width, y + height];\n};\nconst max = values => Math.max(-Infinity, ...values);\nconst min = values => Math.min(Infinity, ...values);\nconst getPolylineBoundingBox = node => {\n  var _node$props17;\n  const points = parsePoints(((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.points) || []);\n  const xValues = points.map(p => p[0]);\n  const yValues = points.map(p => p[1]);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\nconst boundingBoxFns = {\n  [P.Rect]: getRectBoundingBox,\n  [P.Line]: getLineBoundingBox,\n  [P.Path]: getPathBoundingBox,\n  [P.Circle]: getCircleBoundingBox,\n  [P.Ellipse]: getEllipseBoundingBox,\n  [P.Polygon]: getPolylineBoundingBox,\n  [P.Polyline]: getPolylineBoundingBox\n};\nconst getBoundingBox = node => {\n  const boundingBoxFn = boundingBoxFns[node.type];\n  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];\n};\n\nconst setStrokeWidth = (ctx, node) => {\n  var _node$props;\n  const lineWidth = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;\n  if (lineWidth) ctx.lineWidth(lineWidth);\n};\nconst setStrokeColor = (ctx, node) => {\n  var _node$props2;\n  const strokeColor = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;\n  if (strokeColor) ctx.strokeColor(strokeColor);\n};\nconst setOpacity = (ctx, node) => {\n  var _node$props3;\n  const opacity = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;\n  if (!isNil(opacity)) ctx.opacity(opacity);\n};\nconst setFillOpacity = (ctx, node) => {\n  var _node$props4;\n  const fillOpacity = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;\n  if (!isNil(fillOpacity)) ctx.fillOpacity(fillOpacity);\n};\nconst setStrokeOpacity = (ctx, node) => {\n  var _node$props5;\n  const strokeOpacity = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;\n  if (!isNil(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);\n};\nconst setLineJoin = (ctx, node) => {\n  var _node$props6;\n  const lineJoin = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;\n  if (lineJoin) ctx.lineJoin(lineJoin);\n};\nconst setLineCap = (ctx, node) => {\n  var _node$props7;\n  const lineCap = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;\n  if (lineCap) ctx.lineCap(lineCap);\n};\nconst setLineDash = (ctx, node) => {\n  var _node$props8;\n  const value = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;\n  if (value) ctx.dash(value.split(/[\\s,]+/).map(Number));\n};\nconst hasLinearGradientFill = node => {\n  var _node$props9, _node$props9$fill;\n  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === P.LinearGradient;\n};\nconst hasRadialGradientFill = node => {\n  var _node$props10, _node$props10$fill;\n  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === P.RadialGradient;\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = (ctx, node) => {\n  var _node$props11;\n  const bbox = getBoundingBox(node);\n  const gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;\n  const x1 = gradient.props.x1 || 0;\n  const y1 = gradient.props.y1 || 0;\n  const x2 = gradient.props.x2 || 1;\n  const y2 = gradient.props.y2 || 0;\n  const m0 = bbox[2] - bbox[0];\n  const m3 = bbox[3] - bbox[1];\n  const m4 = bbox[0];\n  const m5 = bbox[1];\n  const gx1 = m0 * x1 + m4;\n  const gy1 = m3 * y1 + m5;\n  const gx2 = m0 * x2 + m4;\n  const gy2 = m3 * y2 + m5;\n  const grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n  gradient.children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = (ctx, node) => {\n  var _node$props12;\n  const bbox = getBoundingBox(node);\n  const gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;\n  const cx = gradient.props.cx || 0.5;\n  const cy = gradient.props.cy || 0.5;\n  const fx = gradient.props.fx || cx;\n  const fy = gradient.props.fy || cy;\n  const r = gradient.props.r || 0.5;\n  const m0 = bbox[2] - bbox[0];\n  const m3 = bbox[3] - bbox[1];\n  const m4 = bbox[0];\n  const m5 = bbox[1];\n  const gr = r * m0;\n  const gcx = m0 * cx + m4;\n  const gcy = m3 * cy + m5;\n  const gfx = m0 * fx + m4;\n  const gfy = m3 * fy + m5;\n  const grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n  gradient.children.forEach(stop => {\n    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n  });\n  ctx.fill(grad);\n};\nconst setFillColor = (ctx, node) => {\n  var _node$props13;\n  const fillColor = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;\n  if (fillColor) ctx.fillColor(fillColor);\n};\nconst setFill = (ctx, node) => {\n  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);\n  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);\n  return setFillColor(ctx, node);\n};\nconst draw = (ctx, node) => {\n  const props = node.props || {};\n  if (props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if (props.fill) {\n    ctx.fill(props.fillRule);\n  } else if (props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n};\nconst noop = () => {};\nconst renderFns$1 = {\n  [P.Tspan]: noop,\n  [P.TextInstance]: noop,\n  [P.Path]: renderPath,\n  [P.Rect]: renderRect,\n  [P.Line]: renderLine$1,\n  [P.G]: renderGroup,\n  [P.Text]: renderSvgText,\n  [P.Circle]: renderCircle,\n  [P.Image]: renderImage$1,\n  [P.Ellipse]: renderEllipse,\n  [P.Polygon]: renderPolygon,\n  [P.Polyline]: renderPolyline\n};\nconst renderNode$1 = (ctx, node) => {\n  const renderFn = renderFns$1[node.type];\n  if (renderFn) {\n    renderFn(ctx, node);\n  } else {\n    console.warn(`SVG node of type ${node.type} is not currently supported`);\n  }\n};\nconst drawNode = (ctx, node) => {\n  setLineCap(ctx, node);\n  setLineDash(ctx, node);\n  setLineJoin(ctx, node);\n  setStrokeWidth(ctx, node);\n  setStrokeColor(ctx, node);\n  setFill(ctx, node);\n  setStrokeOpacity(ctx, node);\n  setFillOpacity(ctx, node);\n  setOpacity(ctx, node);\n  applyTransformations(ctx, node);\n  renderNode$1(ctx, node);\n  draw(ctx, node);\n};\nconst clipPath = (ctx, node) => {\n  var _node$props14;\n  const value = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;\n  if (value) {\n    const children = value.children || [];\n    children.forEach(child => renderNode$1(ctx, child));\n    ctx.clip();\n  }\n};\nconst drawChildren = (ctx, node) => {\n  const children = node.children || [];\n  children.forEach(child => {\n    ctx.save();\n    clipPath(ctx, child);\n    drawNode(ctx, child);\n    drawChildren(ctx, child);\n    ctx.restore();\n  });\n};\nconst resolveAspectRatio = (ctx, node) => {\n  const {\n    width,\n    height\n  } = node.box;\n  const {\n    viewBox,\n    preserveAspectRatio = {}\n  } = node.props;\n  const {\n    meetOrSlice = 'meet',\n    align = 'xMidYMid'\n  } = preserveAspectRatio;\n  if (viewBox == null || width == null || height == null) return;\n  const x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;\n  const y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;\n  const logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;\n  const logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height;\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return;\n  }\n  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n    ctx.scale(scaleY, scaleY);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n        break;\n      default:\n        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n        break;\n      default:\n        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n    }\n  }\n};\nconst moveToOrigin = (ctx, node) => {\n  const {\n    top,\n    left\n  } = node.box;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingTop = node.box.paddingTop || 0;\n  ctx.translate(left + paddingLeft, top + paddingTop);\n};\nconst renderSvg = (ctx, node) => {\n  ctx.save();\n  clipNode(ctx, node);\n  moveToOrigin(ctx, node);\n  resolveAspectRatio(ctx, node);\n  drawChildren(ctx, node);\n  ctx.restore();\n};\n\nconst black = {\n  value: [0, 0, 0],\n  opacity: 1\n};\nconst parseColor = hex => {\n  const parsed = colorString.get(hex);\n  if (!parsed) return black;\n  const value = colorString.to.hex(parsed.value.slice(0, 3));\n  const opacity = parsed.value[3];\n  return {\n    value,\n    opacity\n  };\n};\n\n/* eslint-disable no-param-reassign */\nconst DEST_REGEXP = /^#.+/;\nconst isSrcId$1 = src => src.match(DEST_REGEXP);\nconst renderAttachment = (ctx, attachment) => {\n  const {\n    xOffset = 0,\n    yOffset = 0,\n    width,\n    height,\n    image\n  } = attachment;\n  ctx.translate(-width + xOffset, -height + yOffset);\n  ctx.image(image, 0, 0, {\n    fit: [width, height],\n    align: 'center',\n    valign: 'bottom'\n  });\n};\nconst renderAttachments = (ctx, run) => {\n  ctx.save();\n  const {\n    font\n  } = run.attributes;\n  const space = font.glyphForCodePoint(0x20);\n  const objectReplacement = font.glyphForCodePoint(0xfffc);\n  let attachmentAdvance = 0;\n  for (let i = 0; i < run.glyphs.length; i += 1) {\n    const position = run.positions[i];\n    const glyph = run.glyphs[i];\n    attachmentAdvance += position.xAdvance || 0;\n    if (glyph.id === objectReplacement.id && run.attributes.attachment) {\n      ctx.translate(attachmentAdvance, position.yOffset || 0);\n      renderAttachment(ctx, run.attributes.attachment);\n      run.glyphs[i] = space;\n      attachmentAdvance = 0;\n    }\n  }\n  ctx.restore();\n};\nconst renderRun = (ctx, run, options) => {\n  const {\n    font,\n    fontSize,\n    link\n  } = run.attributes;\n  const color = parseColor(run.attributes.color);\n  const opacity = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;\n  const {\n    height,\n    descent,\n    xAdvance\n  } = run;\n  if (options.outlineRuns) {\n    ctx.rect(0, -height, xAdvance, height).stroke();\n  }\n  ctx.fillColor(color.value);\n  ctx.fillOpacity(opacity);\n  if (link) {\n    if (isSrcId$1(link)) {\n      ctx.goTo(0, -height - descent, xAdvance, height, link.slice(1));\n    } else {\n      ctx.link(0, -height - descent, xAdvance, height, link);\n    }\n  }\n  renderAttachments(ctx, run);\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n    for (let i = 0; i < run.glyphs.length; i += 1) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n    try {\n      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n  ctx.translate(xAdvance, 0);\n};\nconst renderBackground$1 = (ctx, rect, backgroundColor) => {\n  const color = parseColor(backgroundColor);\n  ctx.save();\n  ctx.fillOpacity(color.opacity);\n  ctx.rect(rect.x, rect.y, rect.width, rect.height);\n  ctx.fill(color.value);\n  ctx.restore();\n};\nconst renderDecorationLine = (ctx, line) => {\n  ctx.save();\n  ctx.lineWidth(line.rect.height);\n  ctx.strokeOpacity(line.opacity);\n  if (/dashed/.test(line.style)) {\n    ctx.dash(3 * line.rect.height);\n  } else if (/dotted/.test(line.style)) {\n    ctx.dash(line.rect.height);\n  }\n  if (/wavy/.test(line.style)) {\n    const dist = Math.max(2, line.rect.height);\n    let step = 1.1 * dist;\n    const stepCount = Math.floor(line.rect.width / (2 * step));\n\n    // Adjust step to fill entire width\n    const remainingWidth = line.rect.width - stepCount * 2 * step;\n    const adjustment = remainingWidth / stepCount / 2;\n    step += adjustment;\n    const cp1y = line.rect.y + dist;\n    const cp2y = line.rect.y - dist;\n    let {\n      x\n    } = line.rect;\n    ctx.moveTo(line.rect.x, line.rect.y);\n    for (let i = 0; i < stepCount; i += 1) {\n      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);\n      x += 2 * step;\n    }\n  } else {\n    ctx.moveTo(line.rect.x, line.rect.y);\n    ctx.lineTo(line.rect.x + line.rect.width, line.rect.y);\n    if (/double/.test(line.style)) {\n      ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);\n      ctx.lineTo(line.rect.x + line.rect.width, line.rect.y + line.rect.height * 2);\n    }\n  }\n  ctx.stroke(line.color);\n  ctx.restore();\n};\nconst renderLine = (ctx, line, options) => {\n  const lineAscent = line.ascent;\n  if (options.outlineLines) {\n    ctx.rect(line.box.x, line.box.y, line.box.width, line.box.height).stroke();\n  }\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y + lineAscent);\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const isLastRun = i === line.runs.length - 1;\n    if (run.attributes.backgroundColor) {\n      const overflowRight = isLastRun ? line.overflowRight : 0;\n      const backgroundRect = {\n        x: 0,\n        y: -lineAscent,\n        height: line.box.height,\n        width: run.xAdvance - overflowRight\n      };\n      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);\n    }\n    renderRun(ctx, run, options);\n  }\n  ctx.restore();\n  ctx.save();\n  ctx.translate(line.box.x, line.box.y);\n  for (let i = 0; i < line.decorationLines.length; i += 1) {\n    const decorationLine = line.decorationLines[i];\n    renderDecorationLine(ctx, decorationLine);\n  }\n  ctx.restore();\n};\nconst renderBlock = (ctx, block, options) => {\n  block.forEach(line => {\n    renderLine(ctx, line, options);\n  });\n};\nconst renderText = (ctx, node) => {\n  var _node$box, _node$box2;\n  const {\n    top,\n    left\n  } = node.box;\n  const blocks = [node.lines];\n  const paddingTop = ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.paddingTop) || 0;\n  const paddingLeft = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingLeft) || 0;\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  const offsetX = node.alignOffset || 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);\n  blocks.forEach(block => {\n    renderBlock(ctx, block, {});\n  });\n  ctx.restore();\n};\n\nconst renderPage = (ctx, node) => {\n  var _node$props;\n  const {\n    width,\n    height\n  } = node.box;\n  const dpi = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.dpi) || 72;\n  const userUnit = dpi / 72;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0,\n    userUnit\n  });\n};\n\nconst renderNote = (ctx, node) => {\n  var _node$children, _node$style, _node$style2;\n  const {\n    top,\n    left\n  } = node.box;\n  const value = (node === null || node === void 0 ? void 0 : (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || '';\n  const color = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor) || null;\n  const borderWidth = ((_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.borderWidth) || null;\n  ctx.note(left, top, 0, 0, value, {\n    color,\n    borderWidth\n  });\n};\n\nconst isNumeric = n => {\n  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);\n};\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width,\n      height,\n      xOffset,\n      yOffset\n    };\n  }\n  const width = cw;\n  const height = width / ir;\n  const xOffset = isNumeric(px) ? px : 0;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    yOffset,\n    xOffset\n  };\n};\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width,\n      height,\n      yOffset,\n      xOffset\n    };\n  }\n  const height = ch;\n  const width = height * ir;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : 0;\n  return {\n    width,\n    height,\n    xOffset,\n    yOffset\n  };\n};\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0\n  };\n};\nconst resolveObjectFit = function (type, cw, ch, iw, ih, px, py) {\n  if (type === void 0) {\n    type = 'fill';\n  }\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nconst drawImage = function (ctx, node, options) {\n  var _node$style, _node$style2, _node$style3, _node$style4;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    left,\n    top\n  } = node.box;\n  const opacity = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity;\n  const objectFit = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.objectFit;\n  const objectPositionX = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectPositionX;\n  const objectPositionY = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionY;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const imageCache = options.imageCache || new Map();\n  const {\n    width,\n    height,\n    xOffset,\n    yOffset\n  } = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY);\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      const cacheKey = node.image.key;\n      const image = imageCache.get(cacheKey) || ctx.embedImage(node.image.data);\n      if (cacheKey) imageCache.set(cacheKey, image);\n      const imageOpacity = isNil(opacity) ? 1 : opacity;\n      ctx.fillOpacity(imageOpacity).image(image, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n        width,\n        height\n      });\n    } else {\n      console.warn(`Image with src '${JSON.stringify(node.props.src)}' skipped due to invalid dimensions`);\n    }\n  }\n};\nconst renderImage = (ctx, node, options) => {\n  ctx.save();\n  clipNode(ctx, node);\n  drawImage(ctx, node, options);\n  ctx.restore();\n};\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n\n// TODO: Draw debug boxes using clipping to enhance quality\n\nconst debugContent = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n};\nconst debugPadding = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height,\n    paddingLeft = 0,\n    paddingTop = 0,\n    paddingRight = 0,\n    paddingBottom = 0,\n    borderLeftWidth = 0,\n    borderTopWidth = 0,\n    borderRightWidth = 0,\n    borderBottomWidth = 0\n  } = node.box;\n  ctx.fillColor(PADDING_COLOR).opacity(0.5);\n\n  // Padding top\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();\n\n  // Padding left\n  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding right\n  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill();\n\n  // Padding bottom\n  ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n};\nconst getMargin = box => {\n  const marginLeft = box.marginLeft === 'auto' ? 0 : box.marginLeft;\n  const marginTop = box.marginTop === 'auto' ? 0 : box.marginTop;\n  const marginRight = box.marginRight === 'auto' ? 0 : box.marginRight;\n  const marginBottom = box.marginBottom === 'auto' ? 0 : box.marginBottom;\n  return {\n    marginLeft,\n    marginTop,\n    marginRight,\n    marginBottom\n  };\n};\nconst debugMargin = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = getMargin(node.box);\n  ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n\n  // Margin top\n  ctx.rect(left, top - marginTop, width, marginTop).fill();\n\n  // Margin left\n  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill();\n\n  // Margin right\n  ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill();\n\n  // Margin bottom\n  ctx.rect(left, top + height, width, marginBottom).fill();\n};\nconst debugText = (ctx, node) => {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = node.box;\n  const {\n    marginLeft = 0,\n    marginTop = 0,\n    marginRight = 0,\n    marginBottom = 0\n  } = getMargin(node.box);\n  const roundedWidth = Math.round(width + marginLeft + marginRight);\n  const roundedHeight = Math.round(height + marginTop + marginBottom);\n  ctx.fontSize(6).opacity(1).fillColor('black').text(`${roundedWidth} x ${roundedHeight}`, left - marginLeft, Math.max(top - marginTop - 4, 1));\n};\nconst debugOrigin = (ctx, node) => {\n  if (node.origin) {\n    ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n  }\n};\nconst renderDebug = (ctx, node) => {\n  var _node$props;\n  if (!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.debug)) return;\n  ctx.save();\n  debugContent(ctx, node);\n  debugPadding(ctx, node);\n  debugMargin(ctx, node);\n  debugText(ctx, node);\n  debugOrigin(ctx, node);\n  ctx.restore();\n};\n\nconst availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'fillAndStroke', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\nconst painter = ctx => {\n  const p = availableMethods.reduce((acc, prop) => ({\n    ...acc,\n    [prop]: function () {\n      ctx[prop](...arguments);\n      return p;\n    }\n  }), {});\n  return p;\n};\nconst renderCanvas = (ctx, node) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const paddingTop = node.box.paddingTop || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n  if (!availableWidth || !availableHeight) {\n    console.warn('Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  }\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n  ctx.restore();\n};\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);\n\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);\n\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const {\n    top,\n    left,\n    width\n  } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = style;\n\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth));\n\n  // Clip inner right border edge\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top);\n\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth);\n\n  // Clip inner bottom border edge\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    width,\n    height\n  } = layout;\n  const {\n    borderTopWidth,\n    borderLeftWidth,\n    borderBottomWidth\n  } = style;\n\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));\n\n  // Clip inner left border edge\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth));\n\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height);\n\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const {\n    top,\n    left,\n    height\n  } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth\n  } = style;\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n  ctx.stroke();\n  ctx.undash();\n};\nconst shouldRenderBorders = node => node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return;\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth\n  } = node.box;\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid'\n  } = node.style;\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius\n  };\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n  ctx.restore();\n};\n\nconst drawBackground = (ctx, node) => {\n  var _node$style;\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const color = parseColor(node.style.backgroundColor);\n  const nodeOpacity = isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity) ? 1 : node.style.opacity;\n  const opacity = Math.min(color.opacity, nodeOpacity);\n  ctx.fillOpacity(opacity).fillColor(color.value).rect(left, top, width, height).fill();\n};\nconst renderBackground = (ctx, node) => {\n  var _node$style2;\n  const hasBackground = !!node.box && !!((_node$style2 = node.style) !== null && _node$style2 !== void 0 && _node$style2.backgroundColor);\n  if (hasBackground) {\n    ctx.save();\n    clipNode(ctx, node);\n    drawBackground(ctx, node);\n    ctx.restore();\n  }\n};\n\nconst isSrcId = value => /^#.+/.test(value);\nconst setLink = (ctx, node) => {\n  const props = node.props || {};\n  const {\n    top,\n    left,\n    width,\n    height\n  } = node.box;\n  const src = props.src || props.href;\n  if (src) {\n    const isId = isSrcId(src);\n    const method = isId ? 'goTo' : 'link';\n    const value = isId ? src.slice(1) : src;\n    ctx[method](left, top, width, height, value);\n  }\n};\n\nconst setDestination = (ctx, node) => {\n  var _node$props;\n  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.id) {\n    ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n  }\n};\n\nconst isRecursiveNode = node => node.type !== P.Text && node.type !== P.Svg;\nconst renderChildren = (ctx, node, options) => {\n  ctx.save();\n  if (node.box) {\n    ctx.translate(node.box.left, node.box.top);\n  }\n  const children = node.children || [];\n  const renderChild = child => renderNode(ctx, child, options);\n  children.forEach(renderChild);\n  ctx.restore();\n};\nconst renderFns = {\n  [P.Text]: renderText,\n  [P.Note]: renderNote,\n  [P.Image]: renderImage,\n  [P.Canvas]: renderCanvas,\n  [P.Svg]: renderSvg,\n  [P.Link]: setLink\n};\nconst renderNode = (ctx, node, options) => {\n  var _node$style;\n  const overflowHidden = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.overflow) === 'hidden';\n  const shouldRenderChildren = isRecursiveNode(node);\n  if (node.type === P.Page) renderPage(ctx, node);\n  ctx.save();\n  if (overflowHidden) clipNode(ctx, node);\n  applyTransformations(ctx, node);\n  renderBackground(ctx, node);\n  renderBorders(ctx, node);\n  const renderFn = renderFns[node.type];\n  if (renderFn) renderFn(ctx, node, options);\n  if (shouldRenderChildren) renderChildren(ctx, node, options);\n  setDestination(ctx, node);\n  renderDebug(ctx, node);\n  ctx.restore();\n};\n\n/* eslint-disable no-param-reassign */\n\nconst addNodeBookmark = (ctx, node, pageNumber, registry) => {\n  var _node$props;\n  const bookmark = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.bookmark;\n  if (bookmark) {\n    const {\n      title,\n      parent,\n      expanded,\n      zoom,\n      fit\n    } = bookmark;\n    const outline = registry[parent] || ctx.outline;\n    const top = bookmark.top || node.box.top;\n    const left = bookmark.left || node.box.left;\n    const instance = outline.addItem(title, {\n      pageNumber,\n      expanded,\n      top,\n      left,\n      zoom,\n      fit\n    });\n    registry[bookmark.ref] = instance;\n  }\n  if (!node.children) return;\n  node.children.forEach(child => addNodeBookmark(ctx, child, pageNumber, registry));\n};\nconst addBookmarks = (ctx, root) => {\n  const registry = {};\n  const pages = root.children || [];\n  pages.forEach((page, i) => {\n    addNodeBookmark(ctx, page, i, registry);\n  });\n};\n\nconst render = (ctx, doc) => {\n  const pages = doc.children || [];\n  const options = {\n    imageCache: new Map()\n  };\n  pages.forEach(page => renderNode(ctx, page, options));\n  addBookmarks(ctx, doc);\n  ctx.end();\n  return ctx;\n};\n\nexport { render as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}